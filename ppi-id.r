library(shiny)
library(shinycssloaders)
library(DT)
library(tzdb)
library(readr)
library(stringr)
library(dplyr)
library(r3dmol) # (Su & Johnston)
library(bio3d) # (Grant, et al.)
library(httr)
library(jsonlite)
library(vroom)
library(crosstalk)
library(yaml)
library(curl)

# File upload:
# Paste path name to compiled_interactions.csv here
compiled_interactions = read.csv("path/to/file")

# Paste path name to interaction_id.tsv here
domain_motif_interactions = read_tsv("path/to/file")

# Paste path name to elm_classes.tsv here
elm_classes = read_tsv("path/to/file")

# A number of custom functions made to execute the function of this script:
# Function that identifies which tool (InterPro or ELM) was used to generate protein domain/slim information.
# InterPro is assigned 1, ELM is assigned 0, and data that fits neither InterPro nor ELM is assigned -5.
db_id = function(protein){
  # Conditional statement for if the domain data is from InterPro (InterPro Scan)
  if(ncol(protein) == 15){
    db = 1
    
    # Conditional statement for if the SLiM/motif data is from the ELM Database (sequence predict)
  } else if(ncol(protein) == 10){
    db = 0
    
    # Conditional statement for if the SLiM/motif data was obtained using PPID.
  } else if(ncol(protein) == 3){
    db = 2
    
    # Any other sort of tsv is uploaded.
  } else {
    db = -5
  }
  
  return(db)
}

# Correctly formats tables from InterProScan. This function is used within the mixed_algo_ppid() function.
interpro_process <- function(protein){
  firstrow = colnames(protein)
  protein = rbind(firstrow, protein)
  colnames(protein) <- c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
  protein = protein[protein$Database == "Pfam", ]
  
  return(protein)
}

# Function that identifies potential domain-domain interactions using domain information generated by InterPro scan.
interpro_algo <- function(protein1, protein2){
  domain_name_1 = c()
  domain_name_2 = c()
  domain_start_1 = c()
  domain_end_1 = c()
  domain_start_2 = c()
  domain_end_2 = c()
  combined_prob = c()
  
  if(ncol(protein1) != 15 | ncol(protein2) != 15){
    return("Please ensure that Interpro results for both proteins are submitted.")
  } else {
    firstrow1 = colnames(protein1)
    protein1 = rbind(firstrow1, protein1)
    colnames(protein1) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein1 = protein1[protein1$Database == "Pfam", ]
    
    firstrow2 = colnames(protein2)
    protein2 = rbind(firstrow2, protein2)
    colnames(protein2) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein2 = protein2[protein2$Database == "Pfam", ]
    
    for(domain1 in 1:nrow(protein1)){
      for(domain2 in 1:nrow(protein2)){
        if(protein1$ID[domain1] %in% compiled_interactions$domain_1){
          poi1 = compiled_interactions[compiled_interactions$domain_1 == protein1$ID[domain1], ]
          if(protein2$ID[domain2] %in% poi1$domain_2){
            # prob_1 = c()
            # prob_2 = c()
            
            domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
            domain_start_1 = c(domain_start_1, protein1$Start[domain1])
            domain_end_1 = c(domain_end_1, protein1$End[domain1])
            # prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
            
            domain_name_2 = c(domain_name_2, protein2$DomainName[domain2])
            domain_start_2 = c(domain_start_2, protein2$Start[domain2])
            domain_end_2 = c(domain_end_2, protein2$End[domain2])
            # prob_2 = c(prob_2, as.numeric(protein2$prob[domain2]))
            
            # combined_prob = c(combined_prob, prob_1 * prob_2)
          }
        }
        if (protein1$ID[domain1] %in% compiled_interactions$domain_2){
          poi1 = compiled_interactions[compiled_interactions$domain_2 == protein1$ID[domain1], ]
          if(protein2$ID[domain2] %in% poi1$domain_1){
            # prob_1 = c()
            # prob_2 = c()
            
            domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
            domain_start_1 = c(domain_start_1, protein1$Start[domain1])
            domain_end_1 = c(domain_end_1, protein1$End[domain1])
            # prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
            
            domain_name_2 = c(domain_name_2, protein2$DomainName[domain2])
            domain_start_2 = c(domain_start_2, protein2$Start[domain2])
            domain_end_2 = c(domain_end_2, protein2$End[domain2])
            # prob_2 = c(prob_2, as.numeric(protein2$prob[domain2]))
            
            # combined_prob = c(combined_prob, prob_1 * prob_2)
          }
        }
      }
    }
  }
  
  if(length(domain_start_1 != 0)){
    range1 = paste(domain_start_1, domain_end_1, sep = "-")
    range2 = paste(domain_start_2, domain_end_2, sep = "-")
    
    # unsorted_table = unique(data.frame(domain_name_1, domain_name_2, range1, range2))
    # 
    # indices = order(unsorted_table$combined_prob, decreasing = FALSE)
    
    final_table = unique(data.frame(domain_name_1, domain_name_2, range1, range2))
    colnames(final_table) <- c("Domain 1", "Domain 2", "Range 1", "Range 2")
    row.names(final_table) = NULL
    return(final_table)
  } else {
    return(NULL)
  }
}

# Identifies domain-motif interactions and generates the corresponding table frame. Used in the mixed_algo.
# protein1 will always be the Interpro information, while protein2 will always be the ELM information.
mixed_algo_helper = function(protein1, protein2, interpro1st){
  domain_name_1 = c()
  domain_name_2 = c()
  domain_start_1 = c()
  domain_end_1 = c()
  domain_range_2 = c()
  combined_prob = c()
  
  for(domain1 in 1:nrow(protein1)){
    for(domain2 in 1:nrow(protein2)){
      if(protein2$slim[domain2] %in% domain_motif_interactions$elm_identifier){
        poi1 = domain_motif_interactions[domain_motif_interactions$elm_identifier == protein2$slim[domain2], ]
        if(protein1$ID[domain1] %in% poi1$interaction_domain_id){
          # prob_1 = c()
          # prob_2 = c()
          
          domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
          domain_start_1 = c(domain_start_1, protein1$Start[domain1])
          domain_end_1 = c(domain_end_1, protein1$End[domain1])
          # prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
          
          domain_name_2 = c(domain_name_2, protein2$slim[domain2])
          domain_range_2 = c(domain_range_2, protein2$range[domain2])
          # prob_2 = c(prob_2, as.numeric(protein2$probability[domain2]))
          
          # combined_prob = c(combined_prob, prob_1 * prob_2)
        }
      }
    }
  }
  
  if(length(combined_prob) != 0){
    domain_range_1 = paste(domain_start_1, domain_end_1, sep = "-")
    if(interpro1st){
      # unsorted_table = data.frame(domain_name_1, domain_name_2, domain_range_1, domain_range_2, combined_prob)
      # indices = order(unsorted_table$combined_prob, decreasing = FALSE)
      final_table = data.frame(domain_name_1, domain_name_2, domain_range_1, domain_range_2)
      colnames(final_table) <- c("Domain 1", "SLiM 2", "Range 1", "Range 2")
      row.names(final_table) = NULL
    } else {
      # unsorted_table = data.frame(domain_name_2, domain_name_1, domain_range_2, domain_range_1, combined_prob)
      # indices = order(unsorted_table$combined_prob, decreasing = FALSE)
      final_table = data.frame(domain_name_2, domain_name_1, domain_range_2, domain_range_1)
      colnames(final_table) <- c("SLiM 1", "Domain 2", "Range 1", "Range 2")
      row.names(final_table) = NULL
    }
    return(final_table)
  } else {
    return(NULL)
  }
}

# Function that identifies potential domain-motif/motif-domain interactions using information generated by both InterPro and ELM.
mixed_algo = function(protein1, protein2, prot_db_1){
  if(prot_db_1 == 1){
    firstrow1 = colnames(protein1)
    protein1 = rbind(firstrow1, protein1)
    colnames(protein1) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein1 = protein1[protein1$Database == "Pfam", ]
    
    elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
    elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
    
    if(sum(colnames(protein2) == elm_default_table_names) == 10){
      colnames(protein2) = elm_table_names
    } else if(colnames(protein2)[1] %in% domain_motif_interactions$elm_identifier){
      firstrow2 = colnames(protein2)
      protein2 = rbind(firstrow2, protein2)
      colnames(protein2) <- elm_table_names
    }
    
    protein2_range = gsub(" \\[A\\]", ",", protein2$range)
    for(i in 1:length(protein2_range)){
      if(substr(protein2_range[i], nchar(protein2_range[i]), nchar(protein2_range[i])) == ","){
        protein2_range[i] = substr(protein2_range[i], 1, nchar(protein2_range[i])-1)
      }
    }
    protein2$range = NULL
    protein2$range = protein2_range
    
    interpro_prot = protein1
    elm_prot = protein2
    
    return(mixed_algo_helper(interpro_prot, elm_prot, TRUE))
    
  } else {
    firstrow2 = colnames(protein2)
    protein2 = rbind(firstrow2, protein2)
    colnames(protein2) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein2 = protein2[protein2$Database == "Pfam", ]
    
    elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
    elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
    
    if(sum(colnames(protein1) == elm_default_table_names) == 10){
      colnames(protein1) = elm_table_names
    } else if(colnames(protein1)[1] %in% domain_motif_interactions$elm_identifier){
      firstrow1 = colnames(protein1)
      protein1 = rbind(firstrow1, protein1)
      colnames(protein1) <- elm_table_names
    }
    
    protein1_range = gsub(" \\[A\\]", ",", protein1$range)
    for(i in 1:length(protein1_range)){
      if(substr(protein1_range[i], nchar(protein1_range[i]), nchar(protein1_range[i])) == ","){
        protein1_range[i] = substr(protein1_range[i], 1, nchar(protein1_range[i])-1)
      }
    }
    protein1$range = NULL
    protein1$range = protein1_range
    
    interpro_prot = protein2
    elm_prot = protein1
    
    return(mixed_algo_helper(interpro_prot, elm_prot, FALSE))
  }
}

# Function that identifies potential domain-domain interactions based on information taken from InterPro API. Information
# provided in the form of accession number.
interpro_algo_accession <- function(protein1, protein2){
  domain_name_1 = c()
  domain_name_2 = c()
  range_1 = c()
  range_2 = c()
  
  for(domain1 in 1:nrow(protein1)){
    for(domain2 in 1:nrow(protein2)){
      if(protein1$ID[domain1] %in% compiled_interactions$domain_1){
        poi1 = compiled_interactions[compiled_interactions$domain_1 == protein1$ID[domain1], ]
        
        if(protein2$ID[domain2] %in% poi1$domain_2){
          domain_name_1 = c(domain_name_1, protein1$Domain[domain1])
          domain_name_2 = c(domain_name_2, protein2$Domain[domain2])
          range_1 = c(range_1, protein1$Range[domain1])
          range_2 = c(range_2, protein2$Range[domain2])
        }
      }
      if(protein1$ID[domain1] %in% compiled_interactions$domain_2){
        poi2 = compiled_interactions[compiled_interactions$domain_2 == protein1$ID[domain1], ]
        
        if(protein2$ID[domain2] %in% poi2$domain_1){
          domain_name_1 = c(domain_name_1, protein1$Domain[domain1])
          domain_name_2 = c(domain_name_2, protein2$Domain[domain2])
          range_1 = c(range_1, protein1$Range[domain1])
          range_2 = c(range_2, protein2$Range[domain2])
        }
      }
      
      table = unique(data.frame(domain_name_1, domain_name_2, range_1, range_2))
      # Checks to make sure that there are predicted interactions.
      if(ncol(table) != 0){
        colnames(table) = c("Domain 1", "Domain 2", "Range 1", "Range 2")
        # If there are no interactions predicted, a NULL value will be returned.
      } else {
        table = NULL
      }
    }
  }
  return(table)
}

# Function that identifies potential domain-motif interactions based on information taken from InterPro and ELM API. Information
# provided in the form of accession number. The ELM API is slow, and it is easy to overwhelm with small numbers of requests.
# Therefore, this function has been retired. I am retaining this function within the code to archive it, as it still functions
# as it is meant to, and it may serve as a valuable source of information in the future.
mixed_algo_accession <- function(protein1, protein2, prot_db_1_accession){
  # Initialize vectors for all needed information.
  domain_name = c()
  slim_name = c()
  domain_range = c()
  slim_range = c()
  
  # If the user indicated they would like to extract domain information from protein 1.
  if(prot_db_1_accession == "InterPro"){
    for(domain in 1:nrow(protein1)){
      for(slim in 1:nrow(protein2)){
        if(protein1$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein1$ID[domain], ])
          
          if(protein2$SLiM[slim] %in% poi$elm_identifier){
            domain_name = c(domain_name, protein1$Domain[domain])
            slim_name = c(slim_name, protein2$SLiM[slim])
            domain_range = c(domain_range, protein1$Range[domain])
            slim_range = c(slim_range, protein2$Range[slim])
          }
        }
      }
    }
    table = unique(data.frame(domain_name, slim_name, domain_range, slim_range))   
    
    # Checks to make sure that there are predicted interactions.
    if(ncol(table) != 0){
      colnames(table) <- c("Domain 1", "SLiM 2", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else {
      table = NULL
    }
    
    # If the user indicated the would like to extract motif information from protein 1.
  } else if(prot_db_1_accession == "ELM"){
    for(domain in 1:nrow(protein2)){
      for(slim in 1:nrow(protein1)){
        if(protein2$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein2$ID[domain], ])
          
          if(protein1$SLiM[slim] %in% poi$elm_identifier){
            slim_name = c(slim_name, protein1$SLiM[slim])
            domain_name = c(domain_name, protein2$Domain[domain])
            slim_range = c(slim_range, protein1$Range[slim])
            domain_range = c(domain_range, protein2$Range[domain])
          }
        }
      }
    }
    table = unique(data.frame(slim_name, domain_name, slim_range, domain_range))
    
    # Checks to make sure that there are predicted interactions.
    if(ncol(table) != 0){
      colnames(table) <- c("SLiM 1", "Domain 2", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else {
      table = NULL
    }
  }
  
  return(table)
}

# Function that predicts domain-motif interactions using the InterPro and UniProt APIs. The InterPro API outputs all of the
# domains that are detected within a protein, according to the accession number. The UniProt API is used to return the FASTA
# file for a protein accession number. PPID has built-in function that scan the outputted FASTA information for motifs. This
# algorithm will then detect all of the potential DMIs between the two proteins. DMI information (domain_motif_interactions)
# was extracted from the ELM database. This is used for the "Predict from Accession" tab on the UI.
mixed_algo_uniprot <- function(protein1, protein2, prot_db_1_accession){
  # Initialize vectors for all needed information.
  domain_name = c()
  slim_name = c()
  domain_range = c()
  slim_range = c()
  
  # If the user indicated they would like to extract domain information from protein 1.
  if(prot_db_1_accession == "InterPro"){
    protein2$Range = paste(protein2$Start, protein2$Stop, sep = "-")
    for(domain in 1:nrow(protein1)){
      for(slim in 1:nrow(protein2)){
        if(protein1$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein1$ID[domain], ])
          
          if(protein2$SLiM[slim] %in% poi$elm_identifier){
            domain_name = c(domain_name, protein1$Domain[domain])
            slim_name = c(slim_name, protein2$'SLiM Name'[slim])
            domain_range = c(domain_range, protein1$Range[domain])
            slim_range = c(slim_range, protein2$Range[slim])
          }
        }
      }
    }
    table = unique(data.frame(domain_name, slim_name, domain_range, slim_range))   
    
    # Checks to make sure that there are predicted interactions.
    if(ncol(table) != 0){
      colnames(table) <- c("Domain 1", "SLiM 2", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else {
      table = NULL
    }
    
    # If the user indicated the would like to extract motif information from protein 1.
  } else if(prot_db_1_accession == "ELM"){
    protein1$Range = paste(protein1$Start, protein1$Stop, sep = "-")
    for(domain in 1:nrow(protein2)){
      for(slim in 1:nrow(protein1)){
        if(protein2$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein2$ID[domain], ])
          
          if(protein1$SLiM[slim] %in% poi$elm_identifier){
            slim_name = c(slim_name, protein1$'SLiM Name'[slim])
            domain_name = c(domain_name, protein2$Domain[domain])
            slim_range = c(slim_range, protein1$Range[slim])
            domain_range = c(domain_range, protein2$Range[domain])
          }
        }
      }
    }
    table = unique(data.frame(slim_name, domain_name, slim_range, domain_range))
    
    # Checks to make sure that there are predicted interactions.
    if(ncol(table) != 0){
      colnames(table) <- c("SLiM 1", "Domain 2", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else {
      table = NULL
    }
  }
  
  return(table)
}

# Function that identifies potential domain-motif interactions based on information taken from InterPro and the PPID ELM API.
# This is used in te "Predict from Sequence" tab.
mixed_algo_ppid <- function(protein1, protein2, prot_db_1){
  domain_name = c()
  slim_name = c()
  domain_start = c()
  domain_end = c()
  slim_start = c()
  slim_end = c()
  
  # If the first protein's information is from InterPro Scan.
  if(prot_db_1 == 1){
    # Correctly format InterPro information for future analysis.
    protein1 = interpro_process(protein1)
    
    for(domain in 1:nrow(protein1)){
      for(slim in 1:nrow(protein2)){
        if(protein1$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi1 = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein1$ID[domain], ])
          
          if(protein2$"SLiM Name"[slim] %in% poi1$elm_identifier){
            domain_name = c(domain_name, protein1$Description[domain])
            domain_start = c(domain_start, protein1$Start[domain])
            domain_end = c(domain_end, protein1$End[domain])
            
            slim_name = c(slim_name, protein2$"SLiM Name"[slim])
            slim_start = c(slim_start, protein2$Start[slim])
            slim_end = c(slim_end, protein2$Stop[slim])
          }
        }
      }
    }
    domain_range = paste(domain_start, domain_end, sep = "-")
    slim_range = paste(slim_start, slim_end, sep = "-")
    
    table = unique(data.frame(domain_name, slim_name, domain_range, slim_range))
    
    # Checks to make sure that there are predicted interactions
    if(ncol(table) == 4){
      colnames(table) <- c("Domain 1", "SLiM 1", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else if(ncol(table) == 2){
      table = NULL
    } else {
      table = NULL
    }
    
    # If the first protein's information is from PPID ELM API.
  } else if(prot_db_1 == 2){
    # Correctly format InterPro information for future analysis.
    protein2 = interpro_process(protein2)
    
    for(domain in 1:nrow(protein2)){
      for(slim in 1:nrow(protein1)){
        if(protein2$ID[domain] %in% domain_motif_interactions$interaction_domain_id){
          poi2 = na.omit(domain_motif_interactions[domain_motif_interactions$interaction_domain_id == protein2$ID[domain], ])
          
          if(protein1$"SLiM Name"[slim] %in% poi2$elm_identifier){
            slim_name = c(slim_name, protein1$"SLiM Name"[slim])
            slim_start = c(slim_start, protein1$Start[slim])
            slim_end = c(slim_end, protein1$Stop[slim])
            
            domain_name = c(domain_name, protein2$Description[domain])
            domain_start = c(domain_start, protein2$Start[domain])
            domain_end = c(domain_end, protein2$End[domain])
          }
        }
      }
    }
    slim_range = paste(slim_start, slim_end, sep = "-")
    domain_range = paste(domain_start, domain_end, sep = "-")
    
    table = unique(data.frame(slim_name, domain_name, slim_range, domain_range))
    
    # Checks to make sure that there are predicted interactions
    if(ncol(table) == 4){
      colnames(table) <- c("SLiM 1", "Domain 2", "Range 1", "Range 2")
      # If there are no interactions predicted, a NULL value will be returned.
    } else if (ncol(table) == 2){
      table = NULL
    } else {
      table = null
    }
  }
  
  return(table)
}

# Converts a singular range of amino acids (eg. "412-490") as a string to a numeric value
range_conversion = function(range){
  parts = unlist(strsplit(range, "-"))
  numeric_parts = as.numeric(parts)
  range_string = paste(parts[1], parts[2], sep = ":")
  range_correct = eval(parse(text = range_string))
  
  return(range_correct)
}

# Converts multiple ranges of amino acids (eg. "412-490, 520-600") as a string to numeric values
multi_range_conversion = function(range){
  ranges_correct = c()
  parts = unlist(strsplit(range, ", "))
  
  for(i in 1:length(parts)){
    range_part = range_conversion(parts[i])
    ranges_correct = c(ranges_correct, range_part)
  }
  
  return(ranges_correct)
}

# Used in binner function to determine the floor to the hundreds place for a range of amino acids. eg. the 
# hundreds floor of range 150-250 is 100.
hund_floor <- function(num){
  multiplier = floor(num/100)
  return(100 * multiplier)
}

# Used in binner function to determine the ceiling to the hundreds place for a range of amino acids. eg. the
# hundreds ceiling of range 150-250 is 300.
hund_ceiling <- function(num){
  multiplier = ceiling(num/100)
  return(100 * multiplier)
}

# Takes the amino acids as a string and determines the 'bins' to the hundreds place. eg. the hundreds bins of the
# range 150-250 (floor = 100, ceiling = 300) would be 100, 200, 300.
binner <- function(range_as_string){
  nums = as.numeric(unlist(strsplit(range_as_string, split = "-")))
  
  mini = min(nums)
  mini = hund_floor(mini)
  maxi = max(nums)
  maxi = hund_floor(maxi)
  
  counter = mini
  bins = c()
  while(counter <= maxi){
    bins = c(bins, counter)
    counter = counter + 100
  }
  return(bins)
}

# Handles instances when there are more than 1 range in a cell. This largely occurs due to the over-prediction of
# SLiMs.
range_unpacker <-function(split_ranges){
  all_bins = c()
  for(i in 1:length(split_ranges)){
    all_bins = c(all_bins, binner(split_ranges[i]))
  }
  return(all_bins)
}

# Compiles a data frame of all interacting 'bins' between the two proteins. This is used to create a table, which
# is then used to create the heat map.
bin_dataframe <- function(results){
  r1 = results[,'Range 1']
  r2 = results[,'Range 2']
  ranges = cbind(r1, r2)
  total_dataframe = data.frame()
  
  for(k in 1:nrow(ranges)){
    split_ranges1 = unlist(strsplit(ranges[k,1], ', '))
    split_ranges2 = unlist(strsplit(ranges[k,2], ', '))
    
    unpacked_ranges1 = range_unpacker(split_ranges1)
    unpacked_ranges2 = range_unpacker(split_ranges2)
    
    row_numbers = length(unpacked_ranges1) * length(unpacked_ranges2)
    
    for(i in 1:length(unpacked_ranges1)){
      for(j in 1:length(unpacked_ranges2)){
        new_row = data.frame(unpacked_ranges1[i], unpacked_ranges2[j])
        colnames(new_row) <- c("Protein 1", "Protein 2")
        
        total_dataframe = rbind(total_dataframe, new_row)
      }
    }
  }
  
  # total_dataframe = total_dataframe[!(total_dataframe$`Protein 1` == max(total_dataframe$`Protein 1`) | total_dataframe$`Protein 2` == max(total_dataframe$`Protein 2`)), ]
  
  return(total_dataframe)
}

# Helper function for adding amino acid flanks to Pfam protein domains as determined by InterPro. If there is 
# PDB information provided, this function will apply a ceiling 
add_flank_helper <- function(df, range, flank_length, protein_length = NULL){
  for(i in 1:nrow(df)){
    min = min(as.numeric(unlist(strsplit(df[[range]][i], split = '-'))))
    max = max(as.numeric(unlist(strsplit(df[[range]][i], split = '-'))))
    
    if(min - flank_length < 1){
      min = 1
    } else {
      min = min - flank_length
    }
    
    if(!is.null(protein_length)){
      if(max + flank_length > protein_length){
        max = protein_length
      } else {
        max = max + flank_length
      }
    } else {
      max = max + flank_length
    }
    
    new_range = paste(min, max, sep = '-')
    
    df[[range]][i] = new_range
  }
  
  return(df)
}

# Adds user-defined amino acid flanks to Pfam protein domains, as identified by InterPro. 
add_flank <- function(df, protein, flank_length, pdb_object = NULL, chains = NULL){
  if(protein == 1){
    range = 'Range 1'
  } else {
    range = 'Range 2'
  }
  
  if(!is.null(pdb_object)){
    inds = atom.select(pdb_object, 'calpha')
    if(protein == 1){
      ca_1 <- atom.select(pdb_object, string = "calpha", chain = chains[1])
      protein_length = length(pdbseq(pdb_object, inds = ca_1))
    } else {
      ca_2 <- atom.select(pdb_object, string = "calpha", chain = chains[2])
      protein_length = length(pdbseq(pdb_object, inds = ca_2))
    }
    
    flanked_df = add_flank_helper(df, range, flank_length, protein_length)
  } else {
    flanked_df = add_flank_helper(df, range, flank_length)
  }
  
  return(flanked_df)
}

# Filters data frame by PDB contact distances, if a PDB file is provided. Updated version of the function provides
# information on specific residues that are coming in contact. Functions from the Bio3D (Grant, et al.) library 
# were used in this function.
filter_by_distance <- function(df, pdb_object, distance, chains){
  inds = atom.select(pdb_object, 'calpha')
  cont_map = cmap(pdb_object$xyz[inds$xyz], dcut = distance, scut = 10, rmgaps = TRUE)
  
  interacting_pairs = data.frame(which(cont_map == 1, arr.ind = TRUE))
  
  ca_A <- atom.select(pdb_object, string = "calpha", chain = chains[1])
  ca_B <- atom.select(pdb_object, string = "calpha", chain = chains[2])
  
  seq_A = pdbseq(pdb_object, inds = ca_A)
  seq_B = pdbseq(pdb_object, inds = ca_B)
  interacting_A = interacting_pairs[interacting_pairs$row <= length(seq_A), ]
  interacting_AB = interacting_A[interacting_A$col > length(seq_A), ]
  
  df$'Residue 1' = NA
  df$'Residue 2' = NA
  filtered_df = data.frame(matrix(ncol=7,nrow=0))
  colnames(filtered_df) = colnames(df)
  
  if(nrow(interacting_AB) != 0){
    for(i in 1:nrow(df)){
      range1 = df[["Range 1"]][i]
      range2 = df[["Range 2"]][i]
      res1_vect = c()
      res2_vect = c()
      
      if(length(unlist(strsplit(range1, ", "))) > 1){
        range1 = multi_range_conversion(range1)
      } else {
        range1 = range_conversion(range1)
      }
      
      if(length(unlist(strsplit(range2, ", "))) > 1){
        range2 = multi_range_conversion(range2)
      } else {
        range2 = range_conversion(range2)
      }
      
      for(j in 1:nrow(interacting_AB)){
        if(interacting_AB$row[j] %in% range1 && (interacting_AB$col[j] - length(seq_A)) %in% range2){
          res1_vect = c(res1_vect, interacting_AB$row[j])
          res2_vect = c(res2_vect, (interacting_AB$col[j] - length(seq_A)))
          
          res1_vect = unique(res1_vect)
          res2_vect = unique(res2_vect)
        }
      }
      
      if(length(res1_vect) != 0){
        df$'Residue 1'[i] = paste0(res1_vect, collapse = ', ')
        df$'Residue 2'[i] = paste0(res2_vect, collapse = ', ')
        filtered_df = rbind(filtered_df, df[i, ])
      }
    }
  }
  
  return(filtered_df)
}

# For SLiMs that may be over-predicted, this function reduces the amount of displayed slims to ONLY what is
# in contact based on contact filter applied.
clean_filtered_rows = function(filtered_df){
  
  cleaned_df = data.frame(matrix(ncol = ncol(filtered_df), nrow = 0))
  colnames(cleaned_df) = colnames(filtered_df)
  
  for(i in 1:nrow(filtered_df)){
    
    rg1 = unlist(strsplit(filtered_df$`Range 1`[i], ', '))
    rg2 = unlist(strsplit(filtered_df$`Range 2`[i], ', '))
    
    if(is.character(filtered_df$`Residue 1`) && is.character(filtered_df$`Residue 2`)){
      rs1 = as.numeric(unlist(strsplit(filtered_df$`Residue 1`[i], ', ')))
      rs2 = as.numeric(unlist(strsplit(filtered_df$`Residue 2`[i], ', ')))
    } else {
      rs1 = filtered_df$`Residue 1`[i]
      rs2 = filtered_df$`Residue 2`[i]
    }
    
    new_row = filtered_df[i, ]
    
    ran1 = c()
    ran2 = c()
    
    for(j in 1:length(rg1)){
      for(l in 1:length(rs1)){
        if(rs1[l] %in% range_conversion(rg1[j])){
          ran1 = c(ran1, rg1[j])
        }
      }
    }
    for(k in 1:length(rg2)){
      for(m in 1:length(rs2)){
        if(rs2[m] %in% range_conversion(rg2[k])){
          ran2 = c(ran2, rg2[k])
        }
      }
    }
    
    ran1 = unique(ran1)
    ran1 = paste0(ran1, collapse = ", ")
    ran2 = unique(ran2)
    ran2 = paste0(ran2, collapse = ", ")
    
    new_row$`Range 1` = ran1
    new_row$`Range 2` = ran2
    
    cleaned_df = rbind(cleaned_df, new_row)
  }
  
  return(cleaned_df)
}

# Prepares InterPro protein information for contact discovery
interpro_col_names_clean_ranges <- function(protein){
  firstrow = colnames(protein)
  protein = rbind(firstrow, protein)
  colnames(protein) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
  protein = protein[protein$Database == "Pfam", ]
  
  protein$range = paste(protein$Start, protein$End, sep = '-' )
  protein$Start = NULL
  protein$End = NULL
  
  return(protein)
}

# Prepares ELM protein information for contact discovery
elm_col_names_clean_ranges <- function(protein){
  elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
  elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
  
  if(sum(colnames(protein) == elm_default_table_names) == 10){
    colnames(protein) = elm_table_names
  } else if(colnames(protein)[1] %in% domain_motif_interactions$elm_identifier){
    firstrow = colnames(protein)
    protein = rbind(firstrow, protein)
    colnames(protein) <- elm_table_names
  }
  
  protein_range = gsub(" \\[A\\]", ",", protein$range)
  for(i in 1:length(protein_range)){
    if(substr(protein_range[i], nchar(protein_range[i]), nchar(protein_range[i])) == ","){
      protein_range[i] = substr(protein_range[i], 1, nchar(protein_range[i])-1)
    }
  }
  protein$range = NULL
  protein$range = protein_range
  
  return(protein)
}

# Prepares domains identified through InterPro API for contact discovery.
interpro_col_names_clean_ranges_acc <- function(protein){
  colnames(protein) <- c("Domain", "ID", "range")
  
  return(protein)
}

# Prepares motifs identified through PPID for contact discovery.
ppid_col_names_clean_ranges <- function(protein){
  protein$range = paste(protein$Start, protein$Stop, sep = "-")
  
  return(protein)
}

# Converts ranges from protein information from (A-C) to A, B, C.
range_dumper <- function(protein){
  for(i in 1:nrow(protein)){
    dumped_range = multi_range_conversion(protein$range[i])
    dumped_range = paste0(dumped_range, collapse = ' ')
    protein$range[i] = dumped_range
  }
  
  return(protein)
}

# Creates a data frame of contacts within a specified distance (from PDB file)
extract_contacts <- function(pdb_object, distance, chains){
  inds = atom.select(pdb_object, 'calpha')
  cont_map = cmap(pdb_object$xyz[inds$xyz], dcut = distance, scut = 10, rmgaps = TRUE)
  
  interacting_pairs = data.frame(which(cont_map == 1, arr.ind = TRUE))
  
  ca_A <- atom.select(pdb_object, string = "calpha", chain = chains[1])
  ca_B <- atom.select(pdb_object, string = "calpha", chain = chains[2])
  
  seq_A = pdbseq(pdb_object, inds = ca_A)
  seq_B = pdbseq(pdb_object, inds = ca_B)
  interacting_A = interacting_pairs[interacting_pairs$row <= length(seq_A), ]
  interacting_AB = interacting_A[interacting_A$col > length(seq_A), ]
  interacting_AB$col = interacting_AB$col - length(seq_A)
  
  return(interacting_AB)
}

# Creates data frame of all contacts found within contact table and the protein pair information
contact_unearther <- function(protein1, protein2, protein1_packed, protein2_packed, contacts){
  region1 = c()
  region2 = c()
  range1 = c()
  range2 = c()
  residue1 = c()
  residue2 = c()
  
  interpro_names = c("Sequence", "Name", "Length", "Database", "ID", "Description", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1", "range")
  interpro_names_accession = c("Domain", "ID", "range")
  elm_names = c("slim", "sequence", "misc", "description", "location", "pattern", "phi", "structure", "probability", "range")
  ppid_names = c("SLiM Name", "Start", "Stop", "range")
  
  # For the "Predict from Sequence" tab. Protein 1 provides motif information from ELM website, and Protein 2 provides domain
  # information from InterPro website.
  if(identical(colnames(protein1), elm_names) && identical(colnames(protein2), interpro_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$slim[j])
              region2 = c(region2, protein2$DomainName[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Sequence" tab. Protein 1 provides domain information from InterPro website, and Protein 2 provides
    # motif information from the ELM website.
  } else if(identical(colnames(protein1), interpro_names) && identical(colnames(protein2), elm_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$DomainName[j])
              region2 = c(region2, protein2$slim[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Sequence" tab. Both proteins are domain information from the InterPro website.
  } else if(identical(colnames(protein1), interpro_names) && identical(colnames(protein2), interpro_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$DomainName[j])
              region2 = c(region2, protein2$DomainName[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Sequence" tab. Protein 1 provides domain information from the InterPro website, and Protein 2 
    # provides motif information from PPID.
  } else if(identical(colnames(protein1), interpro_names) && identical(colnames(protein2), ppid_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$DomainName[j])
              region2 = c(region2, protein2$'SLiM Name'[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Sequence" tab. Protein 1 provides motif information from PPID, and Protein 2 provides domain
    # information from the InterPro website
  } else if(identical(colnames(protein1), ppid_names) && identical(colnames(protein2), interpro_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$'SLiM Name'[j])
              region2 = c(region2, protein2$DomainName[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Accession" tab. Both proteins are domain information from the InterPro API accessed through PPID.
  } else if(identical(colnames(protein1), interpro_names_accession) && identical(colnames(protein2), interpro_names_accession)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$Domain[j])
              region2 = c(region2, protein2$Domain[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Accession" tab. Protein 1 provides domain information from InterPro API accessed through PPID,
    # and Protein 2 provides motif information from PPID.
  } else if(identical(colnames(protein1), interpro_names_accession) && identical(colnames(protein2), ppid_names)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$Domain[j])
              region2 = c(region2, protein2$'SLiM Name'[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
    # For the "Predict from Accession" tab. Protein 1 provides motif information from PPID, and Protein 2 provides domain 
    # information from InterPro API accessed through PPID.
  } else if(identical(colnames(protein1), ppid_names) && identical(colnames(protein2), interpro_names_accession)){
    for(i in 1:nrow(contacts)){
      for(j in 1:nrow(protein1)){
        if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
          for(k in 1:nrow(protein2)){
            if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
              region1 = c(region1, protein1$'SLiM Name'[j])
              region2 = c(region2, protein2$Domain[k])
              range1 = c(range1, protein1_packed$range[j])
              range2 = c(range2, protein2_packed$range[k])
              residue1 = c(residue1, contacts$row[i])
              residue2 = c(residue2, contacts$col[i])
            }
          }
        }
      }
    }
  }
  
  final_table = data.frame(region1, region2, range1, range2, residue1, residue2)
  if(nrow(final_table) == 0){
    empty_df = data.frame(matrix(ncol = 6))
    colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
    return(empty_df)
  } else {
    colnames(final_table) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
    return(final_table)
  }
}

# Cleans up table of contacts found between proteins, ensuring that all residues within the same domain/SLiM are
# stored in the same row.
consolidate_contacts <- function(cleaned_pdb_contacts){
  protein1_names = unique(cleaned_pdb_contacts$`Protein 1`)
  protein2_names = unique(cleaned_pdb_contacts$`Protein 2`)
  
  if(length(protein1_names) > length(protein2_names)){
    subsetting_vector = protein1_names
    ref_prot = 'Protein 1'
    other_prot = 'Protein 2'
  } else {
    subsetting_vector = protein2_names
    ref_prot = 'Protein 2'
    other_prot = 'Protein 1'
  }
  
  consolidated_df = data.frame(matrix(ncol = ncol(cleaned_pdb_contacts), nrow = 0))
  colnames(consolidated_df) = colnames(cleaned_pdb_contacts)
  
  for(name in subsetting_vector){
    region_subset = unique(cleaned_pdb_contacts[cleaned_pdb_contacts[[ref_prot]] == name, ])
    sub2setting_vector = unique(region_subset[[other_prot]])
    
    sub_df = data.frame(matrix(ncol = ncol(cleaned_pdb_contacts), nrow = 0))
    colnames(sub_df) = colnames(cleaned_pdb_contacts)
    
    for(subname in sub2setting_vector){
      region_sub2set = region_subset[region_subset[[other_prot]] == subname, ]
      new_sub_row = region_sub2set[1, ]
      
      new_sub_row$`Residue 1` = paste0(unique(region_sub2set$`Residue 1`), collapse = ', ')
      new_sub_row$`Residue 2` = paste0(unique(region_sub2set$`Residue 2`), collapse = ', ')
      
      sub_df = rbind(sub_df, new_sub_row)
    }
    
    consolidated_df = rbind(consolidated_df, sub_df)
  }
  return(consolidated_df)
}

# Function allows the user to access the InterPro API to identify domains from an accession number.
interpro_api <- function(accession) {
  interpro_base_api <- "https://www.ebi.ac.uk/interpro/api/entry/pfam/protein/uniprot/"
  interpro_url <- paste0(interpro_base_api, accession)
  
  # Make the GET request
  response <- GET(interpro_url)
  
  # Check if the response was successful
  if (http_status(response)$category == "Success") {
    # Parse JSON response
    data_text <- content(response, "text", encoding = "UTF-8")
    
    # Checks to make sure that the accession number returns results.
    if(!is.null(data_text) && data_text != ""){
      # Read the raw json data.
      data_json <- fromJSON(data_text, flatten = TRUE)
      
      # Initialize vectors for all needed information.
      domain_name = c()
      pfam_id = c()
      domain_start = c()
      domain_end = c()
      
      # Indexes through all domains that are detected using the InterPro API.
      for(domain in 1:length(data_json$results$proteins)){
        # Indexes through all of the repeated domains that are detected using the InterPro API.
        for(repeat_domain in 1:length(data_json$results$proteins[[domain]]$entry_protein_locations[[1]]$fragments)){
          # Saves needed information to appropriate vector.
          domain_name = c(domain_name, data_json$results$metadata.name[domain])
          pfam_id = c(pfam_id, data_json$results$metadata.accession[domain])
          domain_start = c(domain_start, data_json$results$proteins[[domain]]$entry_protein_locations[[1]]$fragments[[repeat_domain]]$start)
          domain_end = c(domain_end, data_json$results$proteins[[domain]]$entry_protein_locations[[1]]$fragments[[repeat_domain]]$end)
        }
      }
      
      # Convert start/end to a range.
      domain_range = paste(domain_start, domain_end, sep = "-")
      # Create a table from the vectors.
      table = data.frame(domain_name, pfam_id, domain_range)
      colnames(table) = c("Domain", "ID", "Range")
      
      return(table)
      
      # For if the accession number doesn't return results. This could result from the submission of a nonsense accession number,
      # or this could result from the accession number not being present in InterPro (for whatever reason). Returning a NULL
      # value will simplify future conditional statements within the code, so that an error message can correctly be displayed
      # if an accession number is not accessible via the InterPro API.
    } else {
      return(NULL)
    }
  }
}

# Function allows the user to access ELM API to identify motifs from an accession number.
elm_api_accession <- function(accession){
  elm_base_api <- "http://elm.eu.org/start_search/"
  pre_elm_url <- paste(elm_base_api, accession, sep = '')
  elm_url <- paste(pre_elm_url, ".tsv", sep = '')
  
  response = GET(elm_url)
  
  if(http_status(response)$category == "Success"){
    data_text = content(response, "text")
    
    # Checks to make sure that the accession number returns results.
    if(data_text != ""){
      # Read as tsv
      slims <- read_tsv(data_text, col_names = TRUE)
      # Trim to the first 3 columns. The other 9 rows all return the same value (FALSE), so this information is not useful for
      # me.
      slims = slims[,1:3]
      
      # Convert start/stop into a range. Get rid of the start and stop columns.
      slims$Range = paste(slims$start, slims$stop, sep = "-")
      slims$start = NULL
      slims$stop = NULL
      
      colnames(slims) = c("SLiM", "Range")
      
      return(slims)
    } else {
      return(NULL)
    }
  }
}

# Function allows the user to access the ELM API to identify SLiMs from a FASTA file.
elm_api_seqs <- function(fasta_seq_slim){
  elm_base_api <- "http://elm.eu.org/start_search/"
  elm_url <- paste(elm_base_api, fasta_seq_slim, sep = '')
  
  response = GET(elm_url)
  
  if(http_status(response)$category == "Success"){
    data_text = content(response, "text")
    
    slims <- read_tsv(data_text, col_names = TRUE)
  }
  
  # Only extract columns of interest
  slims <- slims[,1:3]
  colnames(slims) <- c("SLiM Name", "Start", "Stop")
  return(slims)
}

# Get FASTA file from accession number using UniProt API. 
uniprot_api <- function(accession){
  uniprot_base_api <- "https://rest.uniprot.org/uniprotkb/"
  uniprot_url = paste(uniprot_base_api, accession, ".fasta", sep = '')
  
  response = GET(uniprot_url)
  
  if(http_status(response)$category == "Success"){
    data_text = content(response, "text")
    
    # Checks to make sure that the accession number returns results.
    if(data_text != "Error messages\nThe 'accession' value has invalid format. It should be a valid UniProtKB accession"){
      return(data_text)
    } else {
      return(NULL)
    }
  }
}

# Detect SLiMs from a sequence taken from a FASTA file, as formatted by the uniprot_api() function.
slim_detector <- function(protein){
  # Initialize data frame.
  slims = data.frame(matrix(ncol = 3, nrow = 0))
  colnames(slims) <- c("SLiM Name", "Start", "Stop")
  
  # Index through elm_classes.
  for(class in 1:nrow(elm_classes)){
    slim_of_interest <- str_locate_all(protein, elm_classes$Regex[class])
    
    if(nrow(slim_of_interest[[1]]) > 0){
      new_rows <- data.frame(matrix(ncol = 3, nrow = nrow(slim_of_interest[[1]])))
      colnames(new_rows) <- c("SLiM Name", "Start", "Stop")
      for(row in 1:nrow(new_rows)){
        new_rows$`SLiM Name`[row] = elm_classes$ELMIdentifier[class]
        new_rows$Start[row] = slim_of_interest[[1]][row, 1]
        new_rows$Stop[row] = slim_of_interest[[1]][row, 2]
      }
      slims = rbind(slims, new_rows)
    }
  }
  
  return(slims)
}

# Get table of all motifs from an inputted accession number. This is done using the elm_classes tsv file obtained from the
# ELM database. elm_classes.tsv contains regex which is used to identify potential motifs in a protein sequence. Regex patterns
# within the protein sequence is recognized using the str_locate_all() fxn, which is a part of the stringr package.
# That work is contained within slim_detector() fxn above. This function requires two proteins coded above: 1) uniprot_api() and 
# 2) slim_detector().
generate_motif_table <- function(protein, type){
  if(type == "accession"){
    prelim_fasta = uniprot_api(protein)
    
    if(!is.null(prelim_fasta)){
      prelim_fasta = unlist(strsplit(prelim_fasta, split = "\n"))
      fasta = paste(prelim_fasta[2:length(prelim_fasta)], collapse = "")
      
      table = slim_detector(fasta)
      
      accession_number = unlist(strsplit(prelim_fasta[1], split = "\\|"))[2]
      output = list(accession_number, table) # List allows for proper naming of download files, if the user downloads a SLiM
      # table generated by PPI-ID.
      
      return(output)
      
    } else {
      return(NULL)
    }
  } else if(type == "sequence"){
    if(!is.null(protein) && protein != ""){
      table = slim_detector(protein)
      output = list("SLiMs_from_Sequence_PPI-ID", table)
      
      return(output)
    } else {
      return(NULL)
    }
  }
}

# User interface
ui <- fluidPage(
  tags$head(
    # Disappearing message.
    tags$script('
      Shiny.addCustomMessageHandler("showMessage", function(messageText) {
        var messageBox = $("#messageBox");
        messageBox.text(messageText);
        messageBox.fadeIn();
        setTimeout(function() {
          messageBox.fadeOut();
        }, 3000); // 3000 milliseconds = 3 seconds
      });
    ')
  ),
  
  titlePanel("Protein-Protein Interaction Identifier"),
  tabsetPanel(
    tabPanel("Predict from Accession",
             sidebarLayout(
               sidebarPanel(
                 tags$h4("Provide UniProt Accession Numbers for 2 Proteins Below:", style = "font-size: 14px; font-weight: bold"),
                 fluidRow(
                   column(6, textInput("prot1NumAcc", NULL, placeholder = "Protein 1")),
                   column(6, textInput("prot2NumAcc", NULL, placeholder = "Protein 2"))
                 ),
                 fluidRow(
                   column(6, radioButtons("prot1TypeAcc", "Protein 1", choices = c("Domain", "Motif"))),
                   column(6, radioButtons("prot2TypeAcc", "Protein 2", choices = c("Domain", "Motif")))
                 ),
                 tags$span("PPI-ID can predict domain-domain interactions or domain-motif interactions (at least one protein must have 'Domain' selected). If performing predictions for more than one protein-pairing, please refresh the browser between each prediction.", 
                           style = "display: block; margin-top: -5px; font-size: 12px"),
                 p(),
                 actionButton("goAcc", "Enter", style = "width: 175px; background-color: #337ab7; color: white; border-color: #2e6da4;"),
                 p(),
                 downloadButton("downloadDataAcc", "Download Results"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fileInput("pdbAcc", "Choose PDB file for Multimer", accept = ".pdb"),
                 fluidRow(
                   column(6, actionButton("showpdbAcc", "Show PDB", style = "width: 200px;")),
                   column(6, actionButton("hidepdbAcc", "Hide PDB", style = "width: 200px;"))
                 ),
                 actionButton("refreshPdbAcc", "Revert Model to Original"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 numericInput("pdbFilterAcc", "Contact Distance Filter:", min = 1, max = 100, value = NULL, step = 1),
                 fluidRow(
                   column(6, actionButton("cdFilterAcc", "Filter Predicted Contacts", style = "width: 200px;")),
                   column(6, actionButton("unearthAcc", "Show All Contacts", style = "width: 200px;"))
                 ),
                 actionButton("cdRevertAcc", "Revert", style = "width: 200px;"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fluidRow(
                   column(6, actionButton("cdLabelAcc", "Add Contact Labels", style = "width: 200px;")),
                   column(6, actionButton("cdRemLabelAcc", "Remove Contact Labels", style = "width: 200px;"))
                 ),
                 actionButton("cartoonPleaseAcc", "Cartoon-View Only", style = "width: 200px;"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 tags$h5("3D Molecular Model Color Key:"),
                 tags$h6(tags$span(style = "color: magenta;", "Protein 1"),
                         tags$span(style = "color: blue;", "Protein 2"))
               ),
               mainPanel(
                 withSpinner(DTOutput("dataTableAcc")),
                 uiOutput("messageAcc"),
                 r3dmolOutput("structure3dAcc")
               )
             )
    ),
    tabPanel("Predict from Sequence",
             sidebarLayout(
               sidebarPanel(
                 fileInput("file1", "Choose TSV File for Protein 1:", accept = ".tsv"),
                 fileInput("file2", "Choose TSV File for Protein 2:", accept = ".tsv"),
                 downloadButton("downloadData", "Download Results"),
                 # Functionality of probability filter was taken out due to issues arising from multiplying e-values and p-values
                 # ()
                 # numericInput("numericFilter", "Only Show Probabilities Less Than...", min = 0, max = 1, value = NULL, step = 1e-10),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fileInput("pdb", "Choose PDB file for Multimer", accept = ".pdb"),
                 fluidRow(
                   column(6, actionButton("showpdb", "Show PDB", style = "width: 200px;")),
                   column(6, actionButton("hidepdb", "Hide PDB", style = "width: 200px;"))
                 ),
                 actionButton("refreshPdb", "Revert Model to Original"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 numericInput("pdbFilter", "Contact Distance Filter:", min = 1, max = 100, value = NULL, step = 1),
                 fluidRow(
                   column(6, actionButton("cdFilter", "Filter Predicted Contacts", style = "width: 200px;")),
                   column(6, actionButton("unearth", "Show All Contacts", style = "width: 200px;"))
                 ),
                 actionButton("cdRevert", "Revert", style = "width: 200px;"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fluidRow(
                   column(6, actionButton("cdLabel", "Add Contact Labels", style = "width: 200px;")),
                   column(6, actionButton("cdRemLabel", "Remove Contact Labels", style = "width: 200px;"))
                 ),
                 actionButton("cartoonPlease", "Cartoon-View Only", style = "width: 200px;"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 tags$h5("3D Molecular Model Color Key:"),
                 tags$h6(tags$span(style = "color: hotpink;", "Protein 1"),
                         tags$span(style = "color: #00cc96;", "Protein 2"))
               ),
               mainPanel(
                 DTOutput("dataTable"),
                 tags$div(id = "messageBox", style = "display: none; color: red; font-weight: bold;"),  # Hidden div for displaying messages
                 uiOutput("message"),
                 r3dmolOutput("structure3d")
               )
             )
    ),
    tabPanel("Get SLiM Information",
             sidebarLayout(
               sidebarPanel(
                 textInput("fastaAcc", "Input Protein Information", placeholder = "Accession Number or Sequence"),
                 radioButtons("slimFindType", "Please Select Input Type:", choices = c("Accession Number", "Amino Acid Sequence")),
                 actionButton("goFastaAcc", "Enter", style = "width: 175px; background-color: #337ab7; color: white; border-color: #2e6da4;"),
                 downloadButton("downloadDataSlim", "Download SLiM Information"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 tags$span("Submit accession number or protein amino acid sequence to obtain list of detected motifs.", 
                           style = "display: block; margin-top: -5px; font-size: 12px"),
                 p(),
                 HTML('<p style="font-size: 12px;">This tool is unable to provide the probabilities of each SLiM occuring by random chance. For this information,
                 you may have to use the sequence scanner provided by the
        <a href="http://elm.eu.org/search.html" target="_blank">ELM Database</a>.</p>')
               ),
               mainPanel(
                 withSpinner(DTOutput("slimTable")),
                 br(),
                 uiOutput("messageSlim")
               )
             )
    ),
    tabPanel("About",
             h3("About"),
             HTML('<p>The Protein-Protein Interaction Identifier (PPI-ID) is a structural bioinformatics tool that aids 
              domain-domain interactions (DDIs) or domain-motif (DMIs) interaction prediction between proteins. These predictions can
              be done within the \'Predict from Accession\' tab, which is optimal for predicting DDIs/DMIs between
              entire proteins that have an associated UniProt accession number. To use this tab, you 
              can simply submit protein accession numbers. DDI/DMI prediction can also be done using the \'Predict from Sequence\'
              tab, which is optimal for predicting DDIs/DMIs that involve protein fragments, synthetic proteins, or other amino acid
              sequences that do not have an associated UniProt accession number. To use, provide protein domain information
              generated by 
                  <a href="https://www.ebi.ac.uk/interpro/search/sequence/" target="_blank">InterProScan</a>
              and/or short linear motif (SLiM) information generated by PPI-ID in the \'Predict from Sequence\' tab.
              Do note that PPI-ID is not capable of predicting motif-motif interactions.</p>'),
             p("After running predictions on AlphaFold, the user is able to upload the resulting PDB file and 
              interact with the data frame of predicted interactions. Please note that in order for data frame and 
              the 3D molecular model to properly interact, the accession numbers/sequences submitted to PPI-ID must be the exact 
              same as the sequences that were folded by AlphaFold. Also note that the order of protein sequences folded in
              AlphaFold must match that of the Protein 1 and Protein 2 information upload to PPI-ID. E.g. If accession numbers for
              proteins DifA (P98149) and Cactus (Q03017) are submitted to PPI-ID as Protein 1 and Protein 2 respectively, the 
              respective order of chains within the AlphaFold-produced pdb file must also follow the same order of DifA first
              and Cactus second. The order of chains is determined by the order in which amino acid sequences were added to
             the multimeric FASTA file."),
             p("PPI-ID contains a number of features that facilitates structural analysis of pdb files produced by AlphaFold.
               After PDB file upload, a 'Contact Distance Filter' can be applied, so only predicted interactions that come
               within the user-specified contact distance will populate the table of predicted DDIs/DMIs. After filtering
               has been applied, specific residues that satisfy contact distance filter requirements can be labeled on the
               molecular structure. When labels are added, residues of interest are depicted in ball-and-stick form for improved
               clarity. Additional toggles allows for the removal of labels while maintaining ball-and-stick view of residues of 
               interest and the reversion of the molecular model to its original state. If you would like to perform multiple PPI
               predictions in one session, please ensure that you refresh your browser between each protein-pairing. This will ensure
               that all internal variables are cleared between each prediction, thus allowing PPI-ID to function properly."),
             p("This tool takes advantage of a compiled dataset of domain-domain interactions from the 3did 
               (2022 release) and DOMINE databases. As a result, domains are identified by their Pfam ID, and 
               domain-SLiM interactions are provided by the Eukaryotic Linear Motif (ELM) Database. These databases all document
               PPI information based on experimental crystal structure data. As a result, PPI-ID can not be as accurate in 
               predicting PPIs that have been identified through other methods (e.g. FRET, Y2H, etc.). Furthermore, PPI-ID
               is not capable of predicting novel DDIs/DMIs. PPI-ID purely predicts known interactions as found in crystal structures,
               or as data is reported in the 3did, DOMINE, and ELM databases. Potential 
               interactions are determined according to the appropriate algorithm implemented in the R script."),
             HTML('<p>Additional resources for AlphaFold output analysis (PAE plot generation, ipTM/pTM score fetching, etc.)
             can be accessed at PPI-ID\'s
                  <a href="https://github.com/halg3/PPID" target="_blank">GitHub Page.</a>
             We also highly recommend using PAE plotting and analysis tools that are provided by
                  <a href="https://subtiwiki.uni-goettingen.de/v4/paeViewerDemo" target="_blank">PAE Viewer.</a>
             </p>'),
             h3("Video Guide"),
             tags$iframe(
               width = "960",
               height = "540",
               src = "https://www.youtube.com/embed/3MFsC8eaHvU",
               frameborder = "0",
               allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
               allowfullscreen = NA
             ),
             HTML('<p>If you are running the PPI-ID app locally, you may be unable to view the instructional video on this page.
             You can instead find the video on 
                  <a href="https://youtu.be/3MFsC8eaHvU?si=kGDqrNreYIfWltGw" target="_blank">YouTube.</a>
             </p>'),
             h3("Tips"),
             p("To ensure that tables of predicted DDIs/DMIs can properly interact with an uploaded pdb file, please make sure
               that the order of proteins (e.g. which accession number of file upload you assigned to Protein 1 and Protein 2)
               matches the order of chains in the pdb file.
               Chain order in the multimeric pdb file will correspond with the order of proteins in the FASTA file provided
               to AlphaFold (the first protein in the FASTA file will be Chain 1, and the second will be Chain 2). To make sure
               that protein order in PPI-ID matches chain order of pdb file, make sure that the accession number/uploaded 
               information for Protein 1 correctly matches Chain 1. Complete the same verification for Protein 2."),
             p("When performing more than one PPI predictions in a single session, please be sure to refresh your browser between
               protein pairings. This ensures that PPI-ID can function properly by clearing all internal variables."),
             p("The \'Predict from Accession\' tab is most convenient if you seek to predict/detect DDIs/DMIs between two whole
               proteins that each have their own UniProt accession number. The \'Predict from Sequence\' tab is most convenient if
               you seek to predict/detect DDIs/DMIs involving protein fragments, synthetic proteins, or proteins that do not have an
               associated UniProt accession number."),
             h3("Help"),
             HTML('<p>If you encounter any issues, please submit a pull request to PPI-ID\'s
                  <a href="https://github.com/halg3/PPID/pulls" target="_blank">GitHub Page.</a>
              If you are running this app from RStudios, you may have to first open the tool in a browser before you 
              are properly directed to the GitHub page.</p>'),
             h3("Data Download"),
             p("PPI-ID was validated using 80 AlphaFold-Multimer generated PPI predictions. 40 of these predicted models were used
               to validate domain-domain interactions, and the other 40 were used to validate domain-motif interactions."),
             downloadLink("download_ddi", "Click here to download PDB files for DDI validation (.zip)."),
             p(),
             downloadLink("download_dmi", "Click here to download PDB files for DMI validation (.zip)."),
             p(),
             HTML('<p>For more detailed information on the results of PPI-ID validation, please see Supplementary Tables 1 and 2.
             This data can be found on our
                  <a href="https://github.com/halg3/PPID" target="_blank">GitHub Page.</a>
             </p>')
             
    )
  )
)

# Server logic
server <- function(input, output, session){
  # SERVER INFORMATION FOR 'Predict from Accession' TAB
  
  ## Initialization of reactive values.
  error_message_acc = reactiveVal(NULL)
  displayed_df_acc = reactiveVal(NULL)
  
  accession1 = reactiveVal(NULL)
  accession2 = reactiveVal(NULL)
  protein1_acc = reactiveVal(NULL)
  protein2_acc = reactiveVal(NULL)
  
  results_acc = reactiveVal(FALSE)
  flanked_df_acc = reactiveVal(NULL)
  
  pdb_data_acc = reactiveVal(NULL)
  pdb_object_acc = reactiveVal(NULL)
  chains_acc = reactiveVal(NULL)
  pdb_window_acc = reactiveVal(NULL)
  showing_pdb_acc = reactiveVal(TRUE)
  hide_pdb_acc = reactiveVal(FALSE)
  pres_res_acc = reactiveVal(NULL)
  
  filtered_acc = reactiveVal(FALSE)
  
  ## Waits for the event of someone pressing the 'Enter' button. In order for action to take place, information for 2
  ## proteins must be provided.
  observeEvent(input$goAcc, {
    req(input$prot1NumAcc)
    req(input$prot2NumAcc)
    
    withProgress(message = "Processing...", {
      accession1(input$prot1NumAcc)
      accession2(input$prot2NumAcc)
      
      # Resets data frame if there has been flanks or filters applied.
      if(filtered_acc()){
        pres_res_acc(FALSE)
        
        displayed_df_acc(results_acc())
        output$dataTableAcc <- renderDT(datatable(results_acc(), selection = 'single'))
        
        filtered_acc(FALSE)
      }
      
      # Increment process
      incProgress(0.5, detail = "Fetching protein data...")
      
      if(input$prot1TypeAcc == "Domain" && input$prot2TypeAcc == "Domain"){ # Protein 1 - Domain. Protein 2 - Domain.
        error_message_acc(NULL)
        
        protein1_acc(interpro_api(accession1()))
        protein2_acc(interpro_api(accession2()))
        
        if(is.null(protein1_acc()) && !is.null(protein2)){
          error_message_acc("Please ensure that the accession number for Protein 1 is valid.")
        } else if(!is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession number for Protein 2 is valid.")
        } else if(is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession numbers for both Protein 1 and Protein 2 are valid.")
        } else if(!is.null(protein1_acc()) && !is.null(protein2_acc())){
          results_acc(interpro_algo_accession(protein1_acc(), protein2_acc()))
        }
        
      } else if(input$prot1TypeAcc == "Domain" && input$prot2TypeAcc == "Motif"){ # Protein 1 = Domain. Protein 2 = Motif
        error_message_acc(NULL)
        
        protein1_acc(interpro_api(accession1()))
        protein2_acc(generate_motif_table(accession2(), "accession"))
        protein2_acc(protein2_acc()[[2]])
        
        print(protein1_acc())
        print(protein2_acc())
        
        if(is.null(protein1_acc()) && !is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession number for Protein 1 is valid.")
        } else if(!is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession number for Protein 2 is valid.")
        } else if(is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession numbers for both Protein 1 and Protein 2 are valid.")
        } else if(!is.null(protein1_acc()) && !is.null(protein2_acc())){
          results_acc(mixed_algo_uniprot(protein1_acc(), protein2_acc(), "InterPro"))
        }
        
      } else if(input$prot1TypeAcc == "Motif" && input$prot2TypeAcc == "Domain"){
        error_message_acc(NULL)
        
        protein1_acc(generate_motif_table(accession1(), "accession"))
        protein1_acc(protein1_acc()[[2]])
        protein2_acc(interpro_api(accession2()))
        print(protein1_acc())
        print(protein2_acc())
        
        if(is.null(protein1_acc()) && !is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession number for Protein 1 is valid.")
        } else if(!is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession number for Protein 2 is valid.")
        } else if(is.null(protein1_acc()) && is.null(protein2_acc())){
          error_message_acc("Please ensure that the accession numbers for both Protein 1 and Protein 2 are valid.")
        } else if(!is.null(protein1_acc()) && !is.null(protein2_acc)){
          results_acc(mixed_algo_uniprot(protein1_acc(), protein2_acc(), "ELM"))
        }
        
      } else if(input$prot1TypeAcc == "Motif" && input$prot2TypeAcc == "Motif"){
        error_message_acc("Please provide domain information for at least one protein")
        return(NULL)
      }
      
      # Increment final progress
      incProgress(0.5, detail = "Rendering results...")
    })
  })
  
  ## Displays results_acc() df
  output$dataTableAcc <- renderDT({
    req(is.null(error_message_acc()), results_acc())
    displayed_df_acc(results_acc())
    datatable(results_acc(), selection = 'single')
  })
  
  ## Generates either 1. an error message if a non-valid TSV is uploaded or 2. a message that says no interactions are predicted.
  output$messageAcc <- renderUI({
    # req(is.null(results_acc()))
    # If there is an error (user tried to input motif-motif information), the error message will not be NULL.
    msg_acc <- error_message_acc()
    # If the error message is not NULL, the specified error message (defined within the results_acc() reactive value) will be
    # displayed.
    if (!is.null(msg_acc)) {
      div(style = "color: red;", msg_acc)
      # If the error message is not NULL, but the table returned is NULL (there are no predicted interactions between the two
      # proteins), a message notifying the user of no predicted interactions will appear.
    } else {
      outcome_acc <- results_acc()
      if (is.null(outcome_acc)) {
        div(style = "color: black;", "No potential interactions identified.")
      }
    }
  })
  
  ## Allows user to download data table that is being displayed on their screen.
  output$downloadDataAcc <- downloadHandler(
    filename = function() {
      paste("ppid_prediction", ".tsv", sep = "")
    },
    content = function(file) {
      write_tsv(displayed_df_acc(), file)
    }
  )
  
  ## Allows user to add an amino acid flank to protein 1.
  observeEvent(input$flank1Acc, {
    req(results_acc())
    og_df = results_acc()
    protein = 1
    
    # Will reset the view of the PDB file, if a PDB file is uploaded and is being displayed.
    if(!is.null(pdb_data_acc())){
      req(showing_pdb_acc())
      
      output$structure3dAcc <- renderR3dmol({
        pdb_window_acc()
      })
    }
    
    # If there is an input for flank 1, but not an input for flank 2.
    if((input$flank1Acc != 0 && !is.na(input$flank1Acc) && input$flank1Acc != "") && 
       (input$flank2Acc == 0 || is.na(input$flank2Acc) || input$flank2Acc == "")) {
      # If there is a PDB file uploaded, then sequence information will be extracted from the PDB file to make sure that 
      # aa additions do not span beyond the length of the protein. Eg. You have a protein that is 500aa in length. You have 
      # a domain that starts at the 420th position ends at the 460th position. You want to add a flank that is 50aa on each
      # side of the domain, so this will yield an aa range from (420 - 50 =) 370 to 500 (460 + 50 = 510, which is greater than the 
      # maximum position of the protein, so the maximum position of the protein will be used instead). This logic is repeated
      # Throughout the rest of the input$flank1Acc observeEvent.
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(og_df, protein, input$flank1Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
        # If there is not a PDB file uploaded, aa additions can possibly span beyond the length of the protein.
      } else {
        flanked_df_acc(add_flank(og_df, protein, input$flank1Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
      # If there is not an input for flank 1, but there is an input for flank 2.
    } else if ((input$flank1Acc == 0 || is.na(input$flank1Acc) || input$flank1Acc == "") && 
               (input$flank2Acc != 0 && !is.na(input$flank2Acc) && input$flank2Acc != "")){
      protein = 2
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(og_df, protein, input$flank2Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      } else {
        flanked_df_acc(add_flank(og_df, protein, input$flank2Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
      # If there is an input for both flanks.
    } else if((input$flank1Acc != 0 && !is.na(input$flank1Acc) && input$flank1Acc != "") && 
              (input$flank2Acc != 0 && !is.na(input$flank2Acc) && input$flank2Acc != "")){
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(add_flank(og_df, 1, input$flank1Acc, pdb_object_acc(), chains_acc()), 2, input$flank2Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      } else {
        flanked_df_acc(add_flank(add_flank(og_df, 1, input$flank1Acc), 2, input$flank2Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
      # If there is not an input for either flank.
    } else {
      displayed_df_acc(og_df)
      flanked_df_acc(NULL)
      
      output$dataTableAcc <- renderDT({
        datatable(og_df, selection = 'single')
      })
    }
  })
  
  ## Allows user to add an amino acid flank to protein 2. The logic within this observeEvent is identical to that described
  ## in the observeEvent for input$flank1Acc. For detailed comments on how this observeEvent works, refer to the 
  ## input$flank1Acc.
  observeEvent(input$flank2Acc, {
    req(results_acc())
    og_df = results_acc()
    protein = 2
    
    if(!is.null(pdb_data_acc())){
      req(showing_pdb_acc())
      
      output$structure3dAcc <- renderR3dmol({
        pdb_window_acc()
      })
    }
    
    if((input$flank2Acc != 0 && !is.na(input$flank2Acc) && input$flank2Acc != "") && (input$flank1Acc == 0 || is.na(input$flank1Acc) || input$flank1Acc == "")) {
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(og_df, protein, input$flank2Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      } else {
        flanked_df_acc(add_flank(og_df, protein, input$flank2Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
    } else if ((input$flank2Acc == 0 || is.na(input$flank2Acc) || input$flank2Acc == "") && (input$flank1Acc != 0 && !is.na(input$flank1Acc) && input$flank1Acc != "")){
      protein = 1
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(og_df, protein, input$flank1Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      } else {
        flanked_df_acc(add_flank(og_df, protein, input$flank1Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
    } else if((input$flank1Acc != 0 && !is.na(input$flank1Acc) && input$flank1Acc != "") && (input$flank2Acc != 0 && !is.na(input$flank2Acc) && input$flank2Acc != "")){
      if(!is.null(pdb_object_acc())){
        flanked_df_acc(add_flank(add_flank(og_df, 1, input$flank1Acc, pdb_object_acc(), chains_acc()), 2, input$flank2Acc, pdb_object_acc(), chains_acc()))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      } else {
        flanked_df_acc(add_flank(add_flank(og_df, 1, input$flank1Acc), 2, input$flank2Acc))
        displayed_df_acc(flanked_df_acc())
        output$dataTableAcc <- renderDT({
          datatable(flanked_df_acc(), selection = 'single')
        })
      }
    } else {
      displayed_df_acc(og_df)
      flanked_df_acc(NULL)
      
      output$dataTableAcc <- renderDT({
        datatable(og_df, selection = 'single')
      })
    }
  })
  
  ## Responds to the event of PDB upload. Will present 3D molecular visualization on the web interface.
  observeEvent(input$pdbAcc, {
    req(input$pdbAcc)
    pdb_file <- input$pdbAcc$datapath
    pdb_data_acc(pdb_file)
    
    ### Distinguishes between the two proteins in the multimer, eg. chain A and chain B.
    nr_pdb_object <- read.pdb(pdb_file)
    pdb_object_acc(nr_pdb_object)
    chains_acc(unique(pdb_object_acc()$atom$chain))
    
    ### PDB model rendering was done using functions from the r3dmol library (Su & Johnston).
    pdb_window_acc(
      r3dmol(  
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = pdb_data_acc(), 
          format = "pdb"
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains_acc()[1]),
          style = m_style_cartoon(
            color = "magenta"
          )
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains_acc()[2]),
          style = m_style_cartoon(
            color = "blue"
          )
        )
    )
    
    output$structure3dAcc <- renderR3dmol({
      pdb_window_acc() %>%
        m_zoom_to()
    })
  })
  
  ## Allows user to interact with 3D model using the table of potential interactions
  observeEvent(input$dataTableAcc_rows_selected, {
    req(showing_pdb_acc())
    req(input$pdbAcc)
    selected_row <- input$dataTableAcc_rows_selected
    if(length(selected_row) > 0){
      selected_data <- displayed_df_acc() [selected_row, ]
      
      range1 = selected_data[["Range 1"]]
      range2 = selected_data[["Range 2"]]
      
      if(length(unlist(strsplit(range1, ", "))) > 1){
        range1 = multi_range_conversion(range1)
      } else {
        range1 = range_conversion(range1)
      }
      
      if(length(unlist(strsplit(range2, ", "))) > 1){
        range2 = multi_range_conversion(range2)
      } else {
        range2 = range_conversion(range2)
      }
      
      output$structure3dAcc <- renderR3dmol({
        pdb_window_acc() %>%
          m_set_style(
            sel = m_sel(chain = chains_acc()[1], resi = range1),
            style = m_style_cartoon(
              color = "#00cc96"
            )
          ) %>%
          m_set_style(
            sel = m_sel(chain = chains_acc()[2], resi = range2),
            style = m_style_cartoon(
              color = "orange"
            )
          )
      })
    }
  })
  
  ## Show PDB button
  observeEvent(input$showpdbAcc, {
    showing_pdb_acc(TRUE)
    req(input$pdbAcc)
    
    output$structure3dAcc <- renderR3dmol({
      pdb_window_acc()
    })
  })
  
  ## Hide PDB button
  observeEvent(input$hidepdbAcc, {
    hide_pdb_acc(TRUE)
    showing_pdb_acc(FALSE)
    req(hide_pdb_acc())
    
    output$structure3dAcc <- renderR3dmol({
      r3dmol(
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = NULL,
          format = "pdb"
        )
    })
  })
  
  ## Allows user to refresh PDB file to original state
  observeEvent(input$refreshPdbAcc, {
    req(input$pdbAcc)
    req(showing_pdb_acc())
    
    output$structure3dAcc <- renderR3dmol({
      pdb_window_acc()
    })
  })
  
  ## Allows user to filter data frame based on distances found within PDB file
  observeEvent(input$cdFilterAcc, {
    req(results_acc())
    req(pdb_data_acc())
    # input$pdbFilterAcc is the user-specified contact distance that they would like to filter the table by. input$cdFilterAcc
    # is the input associated with pressing the 'Filter Predicted Contacts' button.
    req(input$pdbFilterAcc)
    
    filtered_acc(TRUE)
    
    output$structure3dAcc <- renderR3dmol({
      pdb_window_acc()
    })
    
    # If the data frame displayed is not one with added amino acid flanks.
    if(is.null(flanked_df_acc())){
      # If there is an input for the user-specified contact distance filter
      if (!is.null(input$pdbFilterAcc) && !is.na(input$pdbFilterAcc) && input$pdbFilterAcc != ""){
        filteredpdb_data <- results_acc()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(results_acc(), pdb_object_acc(), input$pdbFilterAcc, chains_acc())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df_acc(clean_filtered_pdb_data)
            output$dataTableAcc <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df_acc(filteredpdb_data)
            output$dataTableAcc <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
      # If the data frame displayed has added amino acid flanks.
    } else {
      req(flanked_df_acc())
      if (!is.null(input$pdbFilterAcc) && !is.na(input$pdbFilterAcc) && input$pdbFilterAcc != ""){
        filteredpdb_data <- flanked_df_acc()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(flanked_df_acc(), pdb_object_acc(), input$pdbFilterAcc, chains_acc())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df_acc(clean_filtered_pdb_data)
            output$dataTableAcc <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df_acc(filteredpdb_data)
            output$dataTableAcc <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
    }
  })
  
  ## Reverts filtering done on data frame.
  observeEvent(input$cdRevertAcc, {
    req(filtered_acc())
    pres_res_acc(FALSE)
    
    # If the data frame does not contain amino acid flanks.
    if(is.null(flanked_df_acc())){
      displayed_df_acc(results_acc())
      output$dataTableAcc <- renderDT(datatable(results_acc(), selection = 'single'))
      # If the data frame does contain amino acid flanks.
    } else {
      displayed_df_acc(flanked_df_acc())
      output$dataTableAcc <- renderDT(datatable(flanked_df_acc(), selection = 'single'))
    }
    
    # If a PDB model is on display, its view will be reset to not show any selection.
    if(!is.null(pdb_data_acc())){
      req(showing_pdb_acc())
      
      output$structure3dAcc <- renderR3dmol({
        pdb_window_acc()
      })
    }
    
    filtered_acc(FALSE)
  })
  
  ## Allows the user to add labels to residues coming in 'contact,' as determined by the contact distance they 
  ## decided to filter for. Also changes contacting residues to ball and stick form, to improve the user's ability
  ## to pinpoint the location of residues of interest.
  observeEvent(input$cdLabelAcc, {
    pres_res_acc(TRUE)
    req(filtered_acc())
    
    observeEvent(input$dataTableAcc_rows_selected, {
      req(showing_pdb_acc())
      req(pres_res_acc())
      selected_row <- input$dataTableAcc_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df_acc() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3dAcc <- renderR3dmol({
          pdb_window_acc() %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains_acc()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains_acc()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_res_labels(sel = m_sel(chain = chains_acc()[1], resi = as.numeric(unlist(strsplit(res1, ", "))))) %>%
            m_add_res_labels(sel = m_sel(chain = chains_acc()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))))
        })
      }
    })
  })
  
  ## Allows the user to get rid of residue labels, but keeps highlighted residues in ball and stick form.
  observeEvent(input$cdRemLabelAcc, {
    pres_res_acc(FALSE)
    req(filtered_acc())
    
    observeEvent(input$dataTableAcc_rows_selected, {
      selected_row <- input$dataTableAcc_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df_acc() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3dAcc <- renderR3dmol({
          pdb_window_acc() %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains_acc()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains_acc()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            )
        })
      }
    })
  })
  
  ## Allows the user to set PDB view to only cartoon, no ball and stick
  observeEvent(input$cartoonPleaseAcc, {
    req(filtered_acc())
    
    observeEvent(input$dataTableAcc_rows_selected, {
      selected_row <- input$dataTableAcc_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df_acc() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3dAcc <- renderR3dmol({
          pdb_window_acc() %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains_acc()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            )
        })
      }
    })
  })
  
  # Unearth contacts
  observeEvent(input$unearthAcc, {
    req(protein1_acc())
    req(protein2_acc())
    req(pdb_object_acc())
    req(input$pdbFilterAcc)
    
    filtered_acc(TRUE)
    
    if(input$prot1TypeAcc == "Domain"){
      protein1_packed = interpro_col_names_clean_ranges_acc(protein1_acc())
    } else if(input$prot1TypeAcc == "Motif") {
      protein1_packed = ppid_col_names_clean_ranges(protein1_acc())
    } 
    
    if(input$prot2TypeAcc == "Domain"){
      protein2_packed = interpro_col_names_clean_ranges_acc(protein2_acc())
    } else if(input$prot2TypeAcc == "Motif"){
      protein2_packed = ppid_col_names_clean_ranges(protein2_acc())
    } 
    
    protein1 = range_dumper(protein1_packed)
    protein2 = range_dumper(protein2_packed)
    
    contacts = extract_contacts(pdb_object_acc(), input$pdbFilterAcc, chains_acc())
    
    all_pdb_contacts = contact_unearther(protein1, protein2, protein1_packed, protein2_packed, contacts)
    
    if(is.na(all_pdb_contacts[1,1]) && is.null(flanked_df_acc())){ # If there are no detected contacts within the non-flanked predicted ranges, an empty data frame will be displayed
      empty_df = data.frame(matrix(ncol = 6, nrow = 0))
      colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
      output$dataTableAcc <- renderDT(datatable(empty_df, selection = 'single'))
    } else if(is.na(all_pdb_contacts[1,1]) && !is.null(flanked_df_acc())){ # If there are no detected contacts within flanked predicted ranges, only discovered contacts within the flanked range will be displayed
      req(flanked_df_acc())
      if (!is.null(input$pdbFilterAcc) && !is.na(input$pdbFilterAcc) && input$pdbFilterAcc != ""){
        filteredpdb_data <- flanked_df_acc()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(flanked_df_acc(), pdb_object_acc(), input$pdbFilterAcc, chains_acc())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df_acc(clean_filtered_pdb_data)
            output$dataTableAcc <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df_acc(filteredpdb_data)
            output$dataTableAcc <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
    } else { # If there are detected contacts within the user-defined range, they will be displayed
      cleaned_pdb_contacts = clean_filtered_rows(all_pdb_contacts)
      
      consolidated_contacts = consolidate_contacts(cleaned_pdb_contacts)
      
      if(nrow(consolidated_contacts > 0)){
        displayed_df_acc(consolidated_contacts)
        output$dataTableAcc <- renderDT(datatable(consolidated_contacts, selection = 'single'))
      } else {
        empty_df = data.frame(matrix(ncol = 6, nrow = 0))
        colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
        output$dataTableAcc <- renderDT(datatable(empty_df, selection = 'single'))
      }
    }
  })
  
  # SERVER INFORMATION FOR 'Predict from Sequences' TAB
  
  ## Set reactive values for input information
  error_message = reactiveVal(NULL)
  displayed_df = reactiveVal(NULL)
  
  protein1 = reactiveVal(NULL)
  
  protein2 = reactiveVal(NULL)
  
  pdb_data = reactiveVal(NULL)
  
  ## Response to file upload for protein 1.
  observeEvent(input$file1, {
    req(input$file1)
    protein1(read_tsv(input$file1$datapath))
    
    # Disappearing message, urging user to make sure all information is correct.
    if(!is.null(pdb_data()) && !is.null(protein2())){
      messageText <- "Please ensure that the PDB file matches the inputted proteins."
      session$sendCustomMessage(type = "showMessage", message = messageText)
    }
  })
  
  ## Response to file uplaod for protein 2.
  observeEvent(input$file2, {
    req(input$file2)
    protein2(read_tsv(input$file2$datapath))
    
    # Disappearing message, urging user to make sure all information is correct.
    if(!is.null(pdb_data()) && !is.null(protein1())){
      messageText <- "Please ensure that the PDB file matches the inputted proteins."
      session$sendCustomMessage(type = "showMessage", message = messageText)
    }
  })
  
  ## Reactive value: data frame of domains/motifs that are predicted as potential interaction partners
  results <- reactive({
    req(protein1())
    req(protein2())
    
    prot_db_1 <- db_id(protein1())
    prot_db_2 <- db_id(protein2())
    
    # Interpro/Interpro (DDI)
    if(prot_db_1 + prot_db_2 == 2){
      error_message(NULL)
      interpro_algo(protein1(), protein2())
      
      # ELM/ELM - either from ELM predict tool or from PPID (MMI, not valid)
    } else if(prot_db_1 + prot_db_2 == 0 || prot_db_1 + prot_db_2 == 4){
      error_message("Please provide domain information for at least one protein")
      return(NULL)
      
      # Interpro/ELM - from ELM predict tool (DMI)
    } else if(prot_db_1 + prot_db_2 == 1){
      error_message(NULL)
      mixed_algo(protein1(), protein2(), prot_db_1)
      
      # Intepro/ELM - from PPID (DMI)
    } else if(prot_db_1 + prot_db_2 == 3){
      error_message(NULL)
      mixed_algo_ppid(protein1(), protein2(), prot_db_1)
      
      # Erroneous TSV uploaded
    } else if(prot_db_1 + prot_db_2 < 0){
      error_message("Please ensure domain/SLiM information for both proteins are from either InterPro or the ELM Database")
      return(NULL)
    }
  })
  
  ## Displays results() df
  output$dataTable <- renderDT({
    req(is.null(error_message()))
    displayed_df(results())
    datatable(results(), selection = 'single')
  })
  
  flanked_df = reactiveVal(NULL)
  
  ## Allows users to add aa flanks to protein 1
  observeEvent(input$flank1, {
    og_df = results()
    protein = 1
    
    if(!is.null(pdb_data())){
      req(showing_pdb())
      
      output$structure3d <- renderR3dmol({
        pdb_window()
      })
    }
    
    if((input$flank1 != 0 && !is.na(input$flank1) && input$flank1 != "") && 
       (input$flank2 == 0 || is.na(input$flank2) || input$flank2 == "")) {
      if(!is.null(pdb_object())){
        flanked_df(add_flank(og_df, protein, input$flank1, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(og_df, protein, input$flank1))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else if ((input$flank1 == 0 || is.na(input$flank1) || input$flank1 == "") && 
               (input$flank2 != 0 && !is.na(input$flank2) && input$flank2 != "")){
      protein = 2
      if(!is.null(pdb_object())){
        flanked_df(add_flank(og_df, protein, input$flank2, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(og_df, protein, input$flank2))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else if((input$flank1 != 0 && !is.na(input$flank1) && input$flank1 != "") && 
              (input$flank2 != 0 && !is.na(input$flank2) && input$flank2 != "")){
      if(!is.null(pdb_object())){
        flanked_df(add_flank(add_flank(og_df, 1, input$flank1, pdb_object(), chains()), 2, input$flank2, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(add_flank(og_df, 1, input$flank1), 2, input$flank2))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else {
      displayed_df(og_df)
      flanked_df(NULL)
      
      output$dataTable <- renderDT({
        datatable(og_df, selection = 'single')
      })
    }
  })
  
  ## Allows users to add aa flanks to protein 2
  observeEvent(input$flank2, {
    og_df = results()
    protein = 2
    
    if(!is.null(pdb_data())){
      req(showing_pdb())
      
      output$structure3d <- renderR3dmol({
        pdb_window()
      })
    }
    
    if((input$flank2 != 0 && !is.na(input$flank2) && input$flank2 != "") && (input$flank1 == 0 || is.na(input$flank1) || input$flank1 == "")) {
      if(!is.null(pdb_object())){
        flanked_df(add_flank(og_df, protein, input$flank2, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(og_df, protein, input$flank2))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else if ((input$flank2 == 0 || is.na(input$flank2) || input$flank2 == "") && (input$flank1 != 0 && !is.na(input$flank1) && input$flank1 != "")){
      protein = 1
      if(!is.null(pdb_object())){
        flanked_df(add_flank(og_df, protein, input$flank1, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(og_df, protein, input$flank1))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else if((input$flank1 != 0 && !is.na(input$flank1) && input$flank1 != "") && (input$flank2 != 0 && !is.na(input$flank2) && input$flank2 != "")){
      if(!is.null(pdb_object())){
        flanked_df(add_flank(add_flank(og_df, 1, input$flank1, pdb_object(), chains()), 2, input$flank2, pdb_object(), chains()))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      } else {
        flanked_df(add_flank(add_flank(og_df, 1, input$flank1), 2, input$flank2))
        displayed_df(flanked_df())
        output$dataTable <- renderDT({
          datatable(flanked_df(), selection = 'single')
        })
      }
    } else {
      displayed_df(og_df)
      flanked_df(NULL)
      
      output$dataTable <- renderDT({
        datatable(og_df, selection = 'single')
      })
    }
  })
  
  ## Allows the user to input a probability filter.
  observeEvent(input$numericFilter, {
    if (!is.null(input$numericFilter) && !is.na(input$numericFilter) && input$numericFilter != "") {
      filteredData <- results()
      if (!is.null(filteredData)) {
        filteredData <- filteredData[filteredData[["Combined Probability"]] < input$numericFilter, ]
        output$dataTable <- renderDT({
          displayed_df(filteredData)
          datatable(filteredData, selection = 'single')
        })
      }
    } else {
      output$dataTable <- renderDT({
        resultsData <- results()
        displayed_df(resultsData)
        if (!is.null(resultsData)) {
          datatable(resultsData, selection = 'single')
        }
      })
    }
  })
  
  ## Generates either 1. an error message if a non-valid TSV is uploaded or 2. a message that says no interactions are predicted.
  output$message <- renderUI({
    msg <- error_message()
    if (!is.null(msg)) {
      div(style = "color: red;", msg)
    } else {
      outcome <- results()
      if (is.null(outcome)) {
        div(style = "color: black;", "No potential interactions identified.")
      }
    }
  })
  
  ## Allows user to download resulting data frame.
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("ppid_prediction", ".tsv", sep = "")
    },
    content = function(file) {
      write_tsv(displayed_df(), file)
    }
  )
  
  ## Reactive values: needed for 3D visualization of PDB files, identification of chains within PDB files, and for 
  ## allowing the user to hide/show PDB structure after one has been uploaded.
  pdb_object = reactiveVal(NULL)
  pdb_window = reactiveVal(NULL)
  chains = reactiveVal(NULL)
  hide_pdb = reactiveVal(FALSE)
  showing_pdb = reactiveVal(TRUE)
  pres_res = reactiveVal(NULL)
  
  ## Automatically displays structure after upload
  observeEvent(input$pdb, {
    req(input$pdb)
    pdb_file <- input$pdb$datapath
    pdb_data(pdb_file)
    
    ### Distinguishes between the two proteins in the multimer, eg. chain A and chain B.
    nr_pdb_object <- read.pdb(pdb_file)
    pdb_object(nr_pdb_object)
    chains(unique(pdb_object()$atom$chain))
    
    ### PDB model rendering was done using functions from the r3dmol library (Su & Johnston).
    pdb_window(
      r3dmol(  
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = pdb_data(), 
          format = "pdb"
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains()[1]),
          style = m_style_cartoon(
            color = "magenta"
          )
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains()[2]),
          style = m_style_cartoon(
            color = "blue"
          )
        )
    )
    
    output$structure3d <- renderR3dmol({
      pdb_window() %>%
        m_zoom_to()
    })
  })
  
  ## Allows user to interact with 3D model using the table of potential interactions
  observeEvent(input$dataTable_rows_selected, {
    req(showing_pdb())
    req(input$pdb)
    selected_row <- input$dataTable_rows_selected
    if(length(selected_row) > 0){
      selected_data <- displayed_df() [selected_row, ]
      
      range1 = selected_data[["Range 1"]]
      range2 = selected_data[["Range 2"]]
      
      if(length(unlist(strsplit(range1, ", "))) > 1){
        range1 = multi_range_conversion(range1)
      } else {
        range1 = range_conversion(range1)
      }
      
      if(length(unlist(strsplit(range2, ", "))) > 1){
        range2 = multi_range_conversion(range2)
      } else {
        range2 = range_conversion(range2)
      }
      
      output$structure3d <- renderR3dmol({
        pdb_window() %>%
          m_set_style(
            sel = m_sel(chain = chains()[1], resi = range1),
            style = m_style_cartoon(
              color = "#00cc96"
            )
          ) %>%
          m_set_style(
            sel = m_sel(chain = chains()[2], resi = range2),
            style = m_style_cartoon(
              color = "orange"
            )
          )
      })
    }
  })
  
  ## Show PDB button
  observeEvent(input$showpdb, {
    showing_pdb(TRUE)
    req(input$pdb)
    
    output$structure3d <- renderR3dmol({
      pdb_window()
    })
  })
  
  ## Hide PDB button
  observeEvent(input$hidepdb, {
    hide_pdb(TRUE)
    showing_pdb(FALSE)
    req(hide_pdb())
    
    output$structure3d <- renderR3dmol({
      r3dmol(
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = NULL,
          format = "pdb"
        )
    })
  })
  
  ## Allows user to refresh PDB file to original state
  observeEvent(input$refreshPdb, {
    req(input$pdb)
    req(showing_pdb())
    
    output$structure3d <- renderR3dmol({
      pdb_window()
    })
  })
  
  filtered = reactiveVal(FALSE)
  
  ## Allows user to filter data frame based on distances found within PDB file
  observeEvent(input$cdFilter, {
    req(results())
    req(pdb_data())
    req(input$pdbFilter)
    
    filtered(TRUE)
    
    output$structure3d <- renderR3dmol({
      pdb_window()
    })
    
    if(is.null(flanked_df())){
      if (!is.null(input$pdbFilter) && !is.na(input$pdbFilter) && input$pdbFilter != ""){
        filteredpdb_data <- results()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(results(), pdb_object(), input$pdbFilter, chains())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df(clean_filtered_pdb_data)
            output$dataTable <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df(filteredpdb_data)
            output$dataTable <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
    } else {
      req(flanked_df())
      if (!is.null(input$pdbFilter) && !is.na(input$pdbFilter) && input$pdbFilter != ""){
        filteredpdb_data <- flanked_df()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(flanked_df(), pdb_object(), input$pdbFilter, chains())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df(clean_filtered_pdb_data)
            output$dataTable <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df(filteredpdb_data)
            output$dataTable <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
    }
  })
  
  ## Allows user to reveal all contacts detecting within PDB file, not just those predicted interactions that fall
  ## within the desired contact distance.
  observeEvent(input$unearth, {
    req(protein1())
    req(protein2())
    req(pdb_object())
    req(input$pdbFilter)
    
    filtered(TRUE)
    
    if(db_id(protein1()) == 1){
      protein1_packed = interpro_col_names_clean_ranges(protein1())
    } else if(db_id(protein1()) == 0) {
      protein1_packed = elm_col_names_clean_ranges(protein1())
    } else if(db_id(protein1()) == 2){
      protein1_packed = ppid_col_names_clean_ranges(protein1())
    }
    
    
    if(db_id(protein2()) == 1){
      protein2_packed = interpro_col_names_clean_ranges(protein2())
    } else if(db_id(protein2()) == 0){
      protein2_packed = elm_col_names_clean_ranges(protein2())
    } else if(db_id(protein2()) == 2){
      protein2_packed = ppid_col_names_clean_ranges(protein2())
    }
    
    
    protein1 = range_dumper(protein1_packed)
    protein2 = range_dumper(protein2_packed)
    
    contacts = extract_contacts(pdb_object(), input$pdbFilter, chains())
    
    all_pdb_contacts = contact_unearther(protein1, protein2, protein1_packed, protein2_packed, contacts)
    
    if(is.na(all_pdb_contacts[1,1]) && is.null(flanked_df())){ # If there are no detected contacts within the non-flanked predicted ranges, an empty data frame will be displayed
      empty_df = data.frame(matrix(ncol = 6, nrow = 0))
      colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
      output$dataTable <- renderDT(datatable(empty_df, selection = 'single'))
    } else if(is.na(all_pdb_contacts[1,1]) && !is.null(flanked_df())){ # If there are no detected contacts within flanked predicted ranges, only discovered contacts within the flanked range will be displayed
      req(flanked_df())
      if (!is.null(input$pdbFilter) && !is.na(input$pdbFilter) && input$pdbFilter != ""){
        filteredpdb_data <- flanked_df()
        if(!is.null(filteredpdb_data)) {
          filteredpdb_data <- filter_by_distance(flanked_df(), pdb_object(), input$pdbFilter, chains())
          if(nrow(filteredpdb_data) > 0){
            clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
            displayed_df(clean_filtered_pdb_data)
            output$dataTable <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
          } else {
            displayed_df(filteredpdb_data)
            output$dataTable <- renderDT(datatable(filteredpdb_data))
          }
        }
      }
    } else { # If there are detected contacts within the user-defined range, they will be displayed
      cleaned_pdb_contacts = clean_filtered_rows(all_pdb_contacts)
      
      consolidated_contacts = consolidate_contacts(cleaned_pdb_contacts)
      
      if(nrow(consolidated_contacts > 0)){
        displayed_df(consolidated_contacts)
        output$dataTable <- renderDT(datatable(consolidated_contacts, selection = 'single'))
      } else {
        empty_df = data.frame(matrix(ncol = 6, nrow = 0))
        colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
        output$dataTable <- renderDT(datatable(empty_df, selection = 'single'))
      }
    }
  })
  
  ## Allows user to revert the filtered data frame back to the original
  observeEvent(input$cdRevert, {
    req(filtered())
    pres_res(FALSE)
    
    if(is.null(flanked_df())){
      displayed_df(results())
      output$dataTable <- renderDT(datatable(results(), selection = 'single'))
    } else {
      displayed_df(flanked_df())
      output$dataTable <- renderDT(datatable(flanked_df(), selection = 'single'))
    }
    
    if(!is.null(pdb_data())){
      req(showing_pdb())
      
      output$structure3d <- renderR3dmol({
        pdb_window()
      })
    }
    
    filtered(FALSE)
  })
  
  ## Allows the user to add labels to residues coming in 'contact,' as determined by the contact distance they 
  ## decided to filter for. Also changes contacting residues to ball and stick form, to improve the user's ability
  ## to pinpoint the location of residues of interest.
  observeEvent(input$cdLabel, {
    pres_res(TRUE)
    req(filtered())
    
    observeEvent(input$dataTable_rows_selected, {
      req(showing_pdb())
      req(pres_res())
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_res_labels(sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", "))))) %>%
            m_add_res_labels(sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))))
        })
      }
    })
  })
  
  ## Allows the user to get rid of residue labels, but keeps highlighted residues in ball and stick form.
  observeEvent(input$cdRemLabel, {
    pres_res(FALSE)
    req(filtered())
    
    observeEvent(input$dataTable_rows_selected, {
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            )
        })
      }
    })
  })
  
  ## Allows the user to set PDB view to only cartoon, no ball and stick
  observeEvent(input$cartoonPlease, {
    req(filtered())
    
    observeEvent(input$dataTable_rows_selected, {
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "#00cc96"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "orange"
              )
            )
        })
      }
    })
  })
  
  # SERVER INFORMATION FOR "Get SLiM Information" TAB
  # radioButtons("slimFindType", "Please Select Input Type:", choices = c("Accession Number", "Amino Acid Sequence")),
  
  
  ## Set all reactive values
  error_message_slim = reactiveVal(NULL)
  fasta_object = reactiveVal(NULL)
  results_slim = reactiveVal(NULL)
  displayed_df_slim = reactiveVal(NULL)
  
  seq_name_slim = reactiveVal(NULL)
  fasta_seq_slim = reactiveVal(NULL)
  
  ## Observe event of FASTA upload and accordingly assign the fasta_slim() reactive value.
  observeEvent(input$goFastaAcc, {
    req(input$fastaAcc)
    
    if(input$slimFindType == "Accession Number"){
      fasta_object(generate_motif_table(input$fastaAcc, "accession"))
      if(!is.null(fasta_object())){
        slim_table = fasta_object()[[2]]
        results_slim(slim_table)
      } else {
        error_message_slim("Please make sure submitted accession number is valid.")
      }
    } else if(input$slimFindType == "Amino Acid Sequence"){
      fasta_object(generate_motif_table(input$fastaAcc, "sequence"))
      if(!is.null(fasta_object())){
        slim_table = fasta_object()[[2]]
        results_slim(slim_table)
      } else {
        error_message_slim("Please make sure submitted accession number is valid.")
      }
    }
  })
  
  
  ## Display data table of all identified SLiMs.
  output$slimTable <- renderDT({
    req(is.null(error_message_slim()))
    req(results_slim())
    displayed_df_slim(results_slim())
    datatable(displayed_df_slim(), selection = 'single')
  })
  
  # Display error message
  output$messageSlim <- renderUI({
    msg_slim <- error_message_slim()
    if (!is.null(msg_slim)) {
      div(style = "color: red;", msg_slim)
    } 
  })
  
  # Download SLiM table as tsv
  output$downloadDataSlim <- downloadHandler(
    filename = function() {
      paste(fasta_object()[[1]], "_SLiM_predictions", ".tsv", sep = "")
    },
    content = function(file) {
      write_tsv(displayed_df_slim(), file)
    }
  )
  
  # SERVER INFORMATION FOR "About" TAB
  output$download_ddi <- downloadHandler(
    filename = function() {
      paste0("PPI-ID_DDI_Validation.zip")
    },
    content = function(file) {
      ddi_dir <- "/home/atkinson/ppid/Supplementary_test_files/PPID_Validation_Examples_For_DDI"
      ddi_files <- list.files(ddi_dir, pattern = "\\.pdb$", full.names = TRUE)
      temp_dir <- tempdir()
      temp_files <- file.path(temp_dir, basename(ddi_files))
      file.copy(ddi_files, temp_files, overwrite = TRUE)
      utils::zip(zipfile = file, files = temp_files, flags = "-j")
    },
    contentType = "application/zip"
  )
  
  output$download_dmi <- downloadHandler(
    filename = function() {
      paste0("PPI-ID_DMI_Validation.zip")
    },
    content = function(file) {
      dmi_dir <- "/home/atkinson/ppid/Supplementary_test_files/PPID_Validation_Examples_For_DMI"
      dmi_files <- list.files(dmi_dir, pattern = "\\.pdb$", full.names = TRUE)
      temp_dir <- tempdir()
      temp_files <- file.path(temp_dir, basename(dmi_files))
      file.copy(dmi_files, temp_files, overwrite = TRUE)
      utils::zip(zipfile = file, files = temp_files, flags = "-j")
    },
    contentType = "application/zip"
  )
}

# Run app
shiny::runApp(
  shinyApp(ui = ui, server = server),
  host = "146.6.127.203",
  port = 7215
)

