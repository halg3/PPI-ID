library(shiny)
library(shinycssloaders)
library(DT)
library(readr)
library(stringr)
library(dplyr)
library(r3dmol) # (Su & Johnston)
library(bio3d) # (Grant, et al.)
library(pheatmap)
library(reshape2)

# File upload:
# Paste path name to compiled_interactions.csv here
compiled_interactions = read.csv("/Users/hvygoodwin/Downloads/DifB_Project/app/compiled_interactions.csv")

# Paste path name to interaction_id.tsv here
interaction_id = read_tsv("/Users/hvygoodwin/Downloads/DifB_Project/app/interaction_id.tsv")

# A number of custom functions made to execute the function of this script:
# Function that identifies which tool (InterPro or ELM) was used to generate protein domain/slim information.
# InterPro is assigned 1, ELM is assigned 0, and data that fits neither InterPro nor ELM is assigned -5.
db_id = function(protein){
  if(ncol(protein) == 15){
    db = 1
  } else if(ncol(protein) == 10){
    db = 0
  } else {
    db = -5
  }
  
  return(db)
}

# Function that identifies potential domain-domain interactions using domain information generated by InterPro.
interpro_algo <- function(protein1, protein2){
  domain_name_1 = c()
  domain_name_2 = c()
  domain_start_1 = c()
  domain_end_1 = c()
  domain_start_2 = c()
  domain_end_2 = c()
  combined_prob = c()
  
  if(ncol(protein1) != 15 | ncol(protein2) != 15){
    return("Please ensure that Interpro results for both proteins are submitted.")
  } else {
    firstrow1 = colnames(protein1)
    protein1 = rbind(firstrow1, protein1)
    colnames(protein1) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein1 = protein1[protein1$Database == "Pfam", ]
    
    firstrow2 = colnames(protein2)
    protein2 = rbind(firstrow2, protein2)
    colnames(protein2) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein2 = protein2[protein2$Database == "Pfam", ]
    
    for(domain1 in 1:nrow(protein1)){
      for(domain2 in 1:nrow(protein2)){
        if(protein1$ID[domain1] %in% compiled_interactions$domain_1){
          poi1 = compiled_interactions[compiled_interactions$domain_1 == protein1$ID[domain1], ]
          if(protein2$ID[domain2] %in% poi1$domain_2){
            prob_1 = c()
            prob_2 = c()
            
            domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
            domain_start_1 = c(domain_start_1, protein1$Start[domain1])
            domain_end_1 = c(domain_end_1, protein1$End[domain1])
            prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
            
            domain_name_2 = c(domain_name_2, protein2$DomainName[domain2])
            domain_start_2 = c(domain_start_2, protein2$Start[domain2])
            domain_end_2 = c(domain_end_2, protein2$End[domain2])
            prob_2 = c(prob_2, as.numeric(protein2$prob[domain2]))
            
            combined_prob = c(combined_prob, prob_1 * prob_2)
          }
        }
        if (protein1$ID[domain1] %in% compiled_interactions$domain_2){
          poi1 = compiled_interactions[compiled_interactions$domain_2 == protein1$ID[domain1], ]
          if(protein2$ID[domain2] %in% poi1$domain_1){
            prob_1 = c()
            prob_2 = c()
            
            domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
            domain_start_1 = c(domain_start_1, protein1$Start[domain1])
            domain_end_1 = c(domain_end_1, protein1$End[domain1])
            prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
            
            domain_name_2 = c(domain_name_2, protein2$DomainName[domain2])
            domain_start_2 = c(domain_start_2, protein2$Start[domain2])
            domain_end_2 = c(domain_end_2, protein2$End[domain2])
            prob_2 = c(prob_2, as.numeric(protein2$prob[domain2]))
            
            combined_prob = c(combined_prob, prob_1 * prob_2)
          }
        }
      }
    }
  }
  
  if(length(combined_prob != 0)){
    range1 = paste(domain_start_1, domain_end_1, sep = "-")
    range2 = paste(domain_start_2, domain_end_2, sep = "-")
    
    unsorted_table = unique(data.frame(domain_name_1, domain_name_2, range1, range2, combined_prob))
    
    indices = order(unsorted_table$combined_prob, decreasing = FALSE)
    final_table = unsorted_table[indices,]
    colnames(final_table) <- c("Domain 1", "Domain 2", "Range 1", "Range 2", "Combined Probability")
    row.names(final_table) = NULL
    return(final_table)
  } else {
    return(NULL)
  }
}

# Identifies domain-motif interactions and generates the corresponding table frame. Used in the mixed_algo.
# protein1 will always be the Interpro information, while protein2 will always be the ELM information.
mixed_algo_helper = function(protein1, protein2, interpro1st){
  domain_name_1 = c()
  domain_name_2 = c()
  domain_start_1 = c()
  domain_end_1 = c()
  domain_range_2 = c()
  combined_prob = c()
  
  for(domain1 in 1:nrow(protein1)){
    for(domain2 in 1:nrow(protein2)){
      if(protein2$slim[domain2] %in% interaction_id$elm_identifier){
        poi1 = interaction_id[interaction_id$elm_identifier == protein2$slim[domain2], ]
        if(protein1$ID[domain1] %in% poi1$interaction_domain_id){
          prob_1 = c()
          prob_2 = c()
          
          domain_name_1 = c(domain_name_1, protein1$DomainName[domain1])
          domain_start_1 = c(domain_start_1, protein1$Start[domain1])
          domain_end_1 = c(domain_end_1, protein1$End[domain1])
          prob_1 = c(prob_1, as.numeric(protein1$prob[domain1]))
          
          domain_name_2 = c(domain_name_2, protein2$slim[domain2])
          domain_range_2 = c(domain_range_2, protein2$range[domain2])
          prob_2 = c(prob_2, as.numeric(protein2$probability[domain2]))
          
          combined_prob = c(combined_prob, prob_1 * prob_2)
        }
      }
    }
  }
  
  if(length(combined_prob) != 0){
    domain_range_1 = paste(domain_start_1, domain_end_1, sep = "-")
    if(interpro1st){
      unsorted_table = data.frame(domain_name_1, domain_name_2, domain_range_1, domain_range_2, combined_prob)
      indices = order(unsorted_table$combined_prob, decreasing = FALSE)
      final_table = unsorted_table[indices,]
      colnames(final_table) <- c("Domain 1", "SLiM 2", "Range 1", "Range 2", "Combined Probability")
      row.names(final_table) = NULL
    } else {
      unsorted_table = data.frame(domain_name_2, domain_name_1, domain_range_2, domain_range_1, combined_prob)
      indices = order(unsorted_table$combined_prob, decreasing = FALSE)
      final_table = unsorted_table[indices,]
      colnames(final_table) <- c("SLiM1", "Domain 2", "Range 1", "Range 2", "Combined Probability")
      row.names(final_table) = NULL
    }
    return(final_table)
  } else {
    return(NULL)
  }
}

# Function that identifies potential domain-motif/motif-domain interactions using information generated by both InterPro and ELM.
mixed_algo = function(protein1, protein2, prot_db_1){
  if(prot_db_1 == 1){
    firstrow1 = colnames(protein1)
    protein1 = rbind(firstrow1, protein1)
    colnames(protein1) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein1 = protein1[protein1$Database == "Pfam", ]
    
    elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
    elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
    
    if(sum(colnames(protein2) == elm_default_table_names) == 10){
      colnames(protein2) = elm_table_names
    } else if(colnames(protein2)[1] %in% interaction_id$elm_identifier){
      firstrow2 = colnames(protein2)
      protein2 = rbind(firstrow2, protein2)
      colnames(protein2) <- elm_table_names
    }
    
    protein2_range = gsub(" \\[A\\]", ",", protein2$range)
    for(i in 1:length(protein2_range)){
      if(substr(protein2_range[i], nchar(protein2_range[i]), nchar(protein2_range[i])) == ","){
        protein2_range[i] = substr(protein2_range[i], 1, nchar(protein2_range[i])-1)
      }
    }
    protein2$range = NULL
    protein2$range = protein2_range
    
    interpro_prot = protein1
    elm_prot = protein2
    
    return(mixed_algo_helper(interpro_prot, elm_prot, TRUE))
    
  } else {
    firstrow2 = colnames(protein2)
    protein2 = rbind(firstrow2, protein2)
    colnames(protein2) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
    protein2 = protein2[protein2$Database == "Pfam", ]
    
    elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
    elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
    
    if(sum(colnames(protein1) == elm_default_table_names) == 10){
      colnames(protein1) = elm_table_names
    } else if(colnames(protein1)[1] %in% interaction_id$elm_identifier){
      firstrow1 = colnames(protein1)
      protein1 = rbind(firstrow1, protein1)
      colnames(protein1) <- elm_table_names
    }
    
    protein1_range = gsub(" \\[A\\]", ",", protein1$range)
    for(i in 1:length(protein1_range)){
      if(substr(protein1_range[i], nchar(protein1_range[i]), nchar(protein1_range[i])) == ","){
        protein1_range[i] = substr(protein1_range[i], 1, nchar(protein1_range[i])-1)
      }
    }
    protein1$range = NULL
    protein1$range = protein1_range
    
    interpro_prot = protein2
    elm_prot = protein1
    
    return(mixed_algo_helper(interpro_prot, elm_prot, FALSE))
  }
}

# Converts a singular range of amino acids (eg. "412-490") as a string to a numeric value
range_conversion = function(range){
  parts = unlist(strsplit(range, "-"))
  numeric_parts = as.numeric(parts)
  range_string = paste(parts[1], parts[2], sep = ":")
  range_correct = eval(parse(text = range_string))
  
  return(range_correct)
}

# Converts multiple ranges of amino acids (eg. "412-490, 520-600") as a string to numeric values
multi_range_conversion = function(range){
  ranges_correct = c()
  parts = unlist(strsplit(range, ", "))
  
  for(i in 1:length(parts)){
    range_part = range_conversion(parts[i])
    ranges_correct = c(ranges_correct, range_part)
  }
  
  return(ranges_correct)
}

# Used in binner function to determine the floor to the hundreds place for a range of amino acids. eg. the 
# hundreds floor of range 150-250 is 100.
hund_floor <- function(num){
  multiplier = floor(num/100)
  return(100 * multiplier)
}

# Used in binner function to determine the ceiling to the hundreds place for a range of amino acids. eg. the
# hundreds ceiling of range 150-250 is 300.
hund_ceiling <- function(num){
  multiplier = ceiling(num/100)
  return(100 * multiplier)
}

# Takes the amino acids as a string and determines the 'bins' to the hundreds place. eg. the hundreds bins of the
# range 150-250 (floor = 100, ceiling = 300) would be 100, 200, 300.
binner <- function(range_as_string){
  nums = as.numeric(unlist(strsplit(range_as_string, split = "-")))
  
  mini = min(nums)
  mini = hund_floor(mini)
  maxi = max(nums)
  maxi = hund_floor(maxi)
  
  counter = mini
  bins = c()
  while(counter <= maxi){
    bins = c(bins, counter)
    counter = counter + 100
  }
  return(bins)
}

# Handles instances when there are more than 1 range in a cell. This largely occurs due to the over-prediction of
# SLiMs.
range_unpacker <-function(split_ranges){
  all_bins = c()
  for(i in 1:length(split_ranges)){
    all_bins = c(all_bins, binner(split_ranges[i]))
  }
  return(all_bins)
}

# Compiles a data frame of all interacting 'bins' between the two proteins. This is used to create a table, which
# is then used to create the heat map.
bin_dataframe <- function(results){
  r1 = results[,'Range 1']
  r2 = results[,'Range 2']
  ranges = cbind(r1, r2)
  total_dataframe = data.frame()
  
  for(k in 1:nrow(ranges)){
    split_ranges1 = unlist(strsplit(ranges[k,1], ', '))
    split_ranges2 = unlist(strsplit(ranges[k,2], ', '))
    
    unpacked_ranges1 = range_unpacker(split_ranges1)
    unpacked_ranges2 = range_unpacker(split_ranges2)
    
    row_numbers = length(unpacked_ranges1) * length(unpacked_ranges2)
    
    for(i in 1:length(unpacked_ranges1)){
      for(j in 1:length(unpacked_ranges2)){
        new_row = data.frame(unpacked_ranges1[i], unpacked_ranges2[j])
        colnames(new_row) <- c("Protein 1", "Protein 2")
        
        total_dataframe = rbind(total_dataframe, new_row)
      }
    }
  }
  
  # total_dataframe = total_dataframe[!(total_dataframe$`Protein 1` == max(total_dataframe$`Protein 1`) | total_dataframe$`Protein 2` == max(total_dataframe$`Protein 2`)), ]
  
  return(total_dataframe)
}

# Filters data frame by PDB contact distances, if a PDB file is provided. Updated version of the function provides
# information on specific residues that are coming in contact. Functions from the Bio3D (Grant, et al.) library 
# was used in this function.
filter_by_distance <- function(df, pdb_object, distance, chains){
  inds = atom.select(pdb_object, 'calpha')
  cont_map = cmap(pdb_object$xyz[inds$xyz], dcut = distance, scut = 10, rmgaps = TRUE)
  
  interacting_pairs = data.frame(which(cont_map == 1, arr.ind = TRUE))
  
  ca_A <- atom.select(pdb_object, string = "calpha", chain = chains[1])
  ca_B <- atom.select(pdb_object, string = "calpha", chain = chains[2])
  
  seq_A = pdbseq(pdb_object, inds = ca_A)
  seq_B = pdbseq(pdb_object, inds = ca_B)
  interacting_A = interacting_pairs[interacting_pairs$row <= length(seq_A), ]
  interacting_AB = interacting_A[interacting_A$col > length(seq_A), ]
  
  df$'Residue 1' = NA
  df$'Residue 2' = NA
  filtered_df = data.frame(matrix(ncol=7,nrow=0))
  colnames(filtered_df) = colnames(df)
  
  if(nrow(interacting_AB) != 0){
    for(i in 1:nrow(df)){
      range1 = df[["Range 1"]][i]
      range2 = df[["Range 2"]][i]
      res1_vect = c()
      res2_vect = c()
      
      if(length(unlist(strsplit(range1, ", "))) > 1){
        range1 = multi_range_conversion(range1)
      } else {
        range1 = range_conversion(range1)
      }
      
      if(length(unlist(strsplit(range2, ", "))) > 1){
        range2 = multi_range_conversion(range2)
      } else {
        range2 = range_conversion(range2)
      }
      
      for(j in 1:nrow(interacting_AB)){
        if(interacting_AB$row[j] %in% range1 && (interacting_AB$col[j] - length(seq_A)) %in% range2){
          res1_vect = c(res1_vect, interacting_AB$row[j])
          res2_vect = c(res2_vect, (interacting_AB$col[j] - length(seq_A)))
          
          res1_vect = unique(res1_vect)
          res2_vect = unique(res2_vect)
        }
      }
      
      if(length(res1_vect) != 0){
        df$'Residue 1'[i] = paste0(res1_vect, collapse = ', ')
        df$'Residue 2'[i] = paste0(res2_vect, collapse = ', ')
        filtered_df = rbind(filtered_df, df[i, ])
      }
    }
  }
  
  return(filtered_df)
}

# For SLiMs that may be over-predicted, this function reduces the amount of displayed slims to ONLY what is
# in contact based on contact filter applied.
clean_filtered_rows = function(filtered_df){
  
  cleaned_df = data.frame(matrix(ncol = ncol(filtered_df), nrow = 0))
  colnames(cleaned_df) = colnames(filtered_df)
  
  for(i in 1:nrow(filtered_df)){
    
    rg1 = unlist(strsplit(filtered_df$`Range 1`[i], ', '))
    rg2 = unlist(strsplit(filtered_df$`Range 2`[i], ', '))
    
    if(is.character(filtered_df$`Residue 1`) && is.character(filtered_df$`Residue 2`)){
      rs1 = as.numeric(unlist(strsplit(filtered_df$`Residue 1`[i], ', ')))
      rs2 = as.numeric(unlist(strsplit(filtered_df$`Residue 2`[i], ', ')))
    } else {
      rs1 = filtered_df$`Residue 1`[i]
      rs2 = filtered_df$`Residue 2`[i]
    }
    
    new_row = filtered_df[i, ]
    
    ran1 = c()
    ran2 = c()
    
    for(j in 1:length(rg1)){
      for(l in 1:length(rs1)){
        if(rs1[l] %in% range_conversion(rg1[j])){
          ran1 = c(ran1, rg1[j])
        }
      }
    }
    for(k in 1:length(rg2)){
      for(m in 1:length(rs2)){
        if(rs2[m] %in% range_conversion(rg2[k])){
          ran2 = c(ran2, rg2[k])
        }
      }
    }
    
    ran1 = unique(ran1)
    ran1 = paste0(ran1, collapse = ", ")
    ran2 = unique(ran2)
    ran2 = paste0(ran2, collapse = ", ")
    
    new_row$`Range 1` = ran1
    new_row$`Range 2` = ran2
    
    cleaned_df = rbind(cleaned_df, new_row)
  }
  
  return(cleaned_df)
}

# Prepares InterPro protein information for contact discovery
interpro_col_names_clean_ranges <- function(protein){
  firstrow = colnames(protein)
  protein = rbind(firstrow, protein)
  colnames(protein) = c("Sequence", "Name", "Length", "Database", "ID", "Description", "Start", "End", "prob", "T/F", "Date", "Interpro_ID", "DomainName", "GO", "Desc1")
  protein = protein[protein$Database == "Pfam", ]
  
  protein$range = paste(protein$Start, protein$End, sep = '-' )
  protein$Start = NULL
  protein$End = NULL
  
  return(protein)
}

# Prepares ELM protein information for contact discovery
elm_col_names_clean_ranges <- function(protein){
  elm_table_names = c("slim", "sequence", "range", "misc", "description", "location", "pattern", "phi", "structure", "probability")
  elm_default_table_names = c("Elm Name", "Instances (Matched Sequence)", "Positions", "View in Jmol", "Elm Description", "Cell Compartment", "Pattern", "PHI-Blast Instance Mapping", "Structural Filter Info", "Probability")
  
  if(sum(colnames(protein) == elm_default_table_names) == 10){
    colnames(protein) = elm_table_names
  } else if(colnames(protein)[1] %in% interaction_id$elm_identifier){
    firstrow = colnames(protein)
    protein = rbind(firstrow, protein)
    colnames(protein) <- elm_table_names
  }
  
  protein_range = gsub(" \\[A\\]", ",", protein$range)
  for(i in 1:length(protein_range)){
    if(substr(protein_range[i], nchar(protein_range[i]), nchar(protein_range[i])) == ","){
      protein_range[i] = substr(protein_range[i], 1, nchar(protein_range[i])-1)
    }
  }
  protein$range = NULL
  protein$range = protein_range
  
  return(protein)
}

# Converts ranges from protein information from (A-C) to A, B, C.
range_dumper <- function(protein){
  for(i in 1:nrow(protein)){
    dumped_range = multi_range_conversion(protein$range[i])
    dumped_range = paste0(dumped_range, collapse = ' ')
    protein$range[i] = dumped_range
  }
  
  return(protein)
}

# Creates a data frame of contacts within a specified distance (from PDB file)
extract_contacts <- function(pdb_object, distance, chains){
  inds = atom.select(pdb_object, 'calpha')
  cont_map = cmap(pdb_object$xyz[inds$xyz], dcut = distance, scut = 10, rmgaps = TRUE)
  
  interacting_pairs = data.frame(which(cont_map == 1, arr.ind = TRUE))
  
  ca_A <- atom.select(pdb_object, string = "calpha", chain = chains[1])
  ca_B <- atom.select(pdb_object, string = "calpha", chain = chains[2])
  
  seq_A = pdbseq(pdb_object, inds = ca_A)
  seq_B = pdbseq(pdb_object, inds = ca_B)
  interacting_A = interacting_pairs[interacting_pairs$row <= length(seq_A), ]
  interacting_AB = interacting_A[interacting_A$col > length(seq_A), ]
  interacting_AB$col = interacting_AB$col - length(seq_A)
  
  return(interacting_AB)
}

# Creates data frame of all contacts found within contact table and the protein pair information
contact_unearther <- function(protein1, protein2, protein1_packed, protein2_packed, contacts){
  region1 = c()
  region2 = c()
  range1 = c()
  range2 = c()
  residue1 = c()
  residue2 = c()
  
  for(i in 1:nrow(contacts)){
    for(j in 1:nrow(protein1)){
      if(contacts$row[i] %in% as.numeric(unlist(strsplit(protein1$range[j], ' ')))){
        for(k in 1:nrow(protein2)){
          if(contacts$col[i] %in% as.numeric(unlist(strsplit(protein2$range[k], ' ')))){
            region1 = c(region1, protein1$slim[j])
            region2 = c(region2, protein2$DomainName[k])
            range1 = c(range1, protein1_packed$range[j])
            range2 = c(range2, protein2_packed$range[k])
            residue1 = c(residue1, contacts$row[i])
            residue2 = c(residue2, contacts$col[i])
          }
        }
      }
    }
  }
  
  final_table = data.frame(region1, region2, range1, range2, residue1, residue2)
  colnames(final_table) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
  
  return(final_table)
}

# Cleans up table of contacts found between proteins, ensuring that all residues within the same domain/SLiM are
# stored in the same row.
consolidate_contacts <- function(cleaned_pdb_contacts){
  protein1_names = unique(cleaned_pdb_contacts$`Protein 1`)
  protein2_names = unique(cleaned_pdb_contacts$`Protein 2`)
  
  if(length(protein1_names) > length(protein2_names)){
    subsetting_vector = protein1_names
    ref_prot = 'Protein 1'
    other_prot = 'Protein 2'
  } else {
    subsetting_vector = protein2_names
    ref_prot = 'Protein 2'
    other_prot = 'Protein 1'
  }
  
  consolidated_df = data.frame(matrix(ncol = ncol(cleaned_pdb_contacts), nrow = 0))
  colnames(consolidated_df) = colnames(cleaned_pdb_contacts)
  
  for(name in subsetting_vector){
    region_subset = unique(cleaned_pdb_contacts[cleaned_pdb_contacts[[ref_prot]] == name, ])
    sub2setting_vector = unique(region_subset[[other_prot]])
    
    sub_df = data.frame(matrix(ncol = ncol(cleaned_pdb_contacts), nrow = 0))
    colnames(sub_df) = colnames(cleaned_pdb_contacts)
    
    for(subname in sub2setting_vector){
      region_sub2set = region_subset[region_subset[[other_prot]] == subname, ]
      new_sub_row = region_sub2set[1, ]
      
      new_sub_row$`Residue 1` = paste0(unique(region_sub2set$`Residue 1`), collapse = ', ')
      new_sub_row$`Residue 2` = paste0(unique(region_sub2set$`Residue 2`), collapse = ', ')
      
      sub_df = rbind(sub_df, new_sub_row)
    }
    
    consolidated_df = rbind(consolidated_df, sub_df)
  }
  return(consolidated_df)
}

# User interface
ui <- fluidPage(
  titlePanel("Protein-Protein Interaction Identifier"),
  tabsetPanel(
    tabPanel("Predict",
             sidebarLayout(
               sidebarPanel(
                 fileInput("file1", "Choose TSV File for Protein 1:", accept = ".tsv"),
                 fileInput("file2", "Choose TSV File for Protein 2:", accept = ".tsv"),
                 fluidRow(
                   column(6, actionButton("show", "Show Predictions Heat Map", style = "width: 200px;")),
                   column(6, actionButton("hide", "Hide Predictions Heat Map", style = "width: 200px;"))
                 ),
                 p(" "),
                 downloadButton("downloadData", "Download Results"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 numericInput("numericFilter", "Only Show Probabilities Less Than...", min = 0, max = 1, value = NULL, step = 1e-10),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fileInput("pdb", "Choose PDB file for Multimer", accept = ".pdb"),
                 fluidRow(
                   column(6, actionButton("showpdb", "Show PDB", style = "width: 200px;")),
                   column(6, actionButton("hidepdb", "Hide PDB", style = "width: 200px;"))
                 ),
                 p(" "),
                 actionButton("refreshPdb", "Revert Model to Original"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 numericInput("pdbFilter", "Contact Distance Filter:", min = 1, max = 100, value = NULL, step = 1),
                 fluidRow(
                   column(6, actionButton("cdFilter", "Filter", style = "width: 200px;")),
                   column(6, actionButton("cdRevert", "Revert", style = "width: 200px;"))
                 ),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fluidRow(
                   column(6, actionButton("unearth", "Show All Contacts", style = "width: 200px;")),
                   column(6, actionButton("cdRevert", "Show Only Predicted", style = "width: 200px;"))
                 ),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 fluidRow(
                   column(6, actionButton("cdLabel", "Add Contact Labels", style = "width: 200px;")),
                   column(6, actionButton("cdRemLabel", "Remove Contact Labels", style = "width: 200px;"))
                 ),
                 actionButton("cartoonPlease", "Cartoon-View Only", style = "width: 200px;"),
                 tags$hr(style = "border-top: 1px solid #444444;"),
                 tags$h5("Heat Map Axes:"),
                 tags$h6("Vertical Axis - Protein 1", style = "font-weight: 350;"),
                 tags$h6("Horizontal Axis - Protein 2", style = "font-weight: 350;"),
                 tags$h5("3D Molecular Model Color Key:"),
                 tags$h6(tags$span(style = "color: hotpink;", "Protein 1"),
                         tags$span(style = "color: #00cc96;", "Protein 2"))
               ),
               mainPanel(
                 DTOutput("dataTable"),
                 uiOutput("message"),
                 conditionalPanel(
                   condition = "output.plotVisible == true",
                   withSpinner(plotOutput("heatmap")),
                 ),
                 r3dmolOutput("structure3d")
               )
             )
    ),
    tabPanel("About",
             h3("About"),
             h4("This work?"),
             h3("Help"),
             h3("References"),
             p("Test"),
             p("Test")
    )
  )
)

# Server logic
server <- function(input, output, session){
  error_message = reactiveVal(NULL)
  displayed_df = reactiveVal(NULL)
  
  protein1 = reactiveVal(NULL)
  protein2 = reactiveVal(NULL)
  
  observeEvent(input$file1, {
    req(input$file1)
    protein1(read_tsv(input$file1$datapath))
  })
  
  observeEvent(input$file2, {
    req(input$file2)
    protein2(read_tsv(input$file2$datapath))
  })
  
  # Reactive value: data frame of domains/motifs that are predicted as potential interaction partners
  results <- reactive({
    req(protein1())
    req(protein2())
    
    prot_db_1 <- db_id(protein1())
    prot_db_2 <- db_id(protein2())
    
    if(prot_db_1 + prot_db_2 == 2){
      error_message(NULL)
      interpro_algo(protein1(), protein2())
    } else if(prot_db_1 + prot_db_2 == 0){
      error_message("Please provide domain information for at least one protein")
      return(NULL)
    } else if(prot_db_1 + prot_db_2 == 1){
      error_message(NULL)
      mixed_algo(protein1(), protein2(), prot_db_1)
    } else {
      error_message("Please ensure domain/SLiM information for both proteins are from either InterPro or the ELM Database")
      return(NULL)
    }
  })
  
  # Reactive value: data frame of all of the 100 amino acid long windows of potential interacting patterns used to generate heat map.
  final_df <- reactive({
    res_df <- results()
    req(res_df)
    bin_dataframe(res_df)
  })
  
  # Reactive value: final_df as a table that is used to generate heat map
  final_table <- reactive({
    df <- final_df()
    req(df)
    # Create contingency table using dcast
    dt <- dcast(df, `Protein 1` ~ `Protein 2`, length)
    # Set row names from the first column (Protein 1)
    row.names(dt) <- dt[, 1]
    # Remove the first column (Protein 1) if not needed in the heatmap
    dt <- dt[, -1]
    return(dt)
  })
  
  output$dataTable <- renderDT({
    req(is.null(error_message()))
    displayed_df(results())
    datatable(results(), selection = 'single')
  })
  
  # Allows the user to input a probability filter.
  observeEvent(input$numericFilter, {
    if (!is.null(input$numericFilter) && !is.na(input$numericFilter) && input$numericFilter != "") {
      filteredData <- results()
      if (!is.null(filteredData)) {
        filteredData <- filteredData[filteredData[["Combined Probability"]] < input$numericFilter, ]
        output$dataTable <- renderDT({
          displayed_df(filteredData)
          datatable(filteredData, selection = 'single')
        })
      }
    } else {
      output$dataTable <- renderDT({
        resultsData <- results()
        displayed_df(resultsData)
        if (!is.null(resultsData)) {
          datatable(resultsData, selection = 'single')
        }
      })
    }
  })
  
  # Generates either 1. an error message if a non-valid TSV is uploaded or 2. a message that says no interactions are predicted.
  output$message <- renderUI({
    msg <- error_message()
    if (!is.null(msg)) {
      div(style = "color: red;", msg)
    } else {
      outcome <- results()
      if (is.null(outcome)) {
        div(style = "color: black;", "No potential interactions identified.")
      }
    }
  })
  
  # Allows user to download resulting data frame.
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("ddip-prediction", Sys.Date(), ".tsv", sep = "")
    },
    content = function(file) {
      write_tsv(results(), file)
    }
  )
  
  # Reactive value: boolean value that is used to allow user to hide/show heat map.
  plotVisible <- reactiveVal(FALSE)
  
  observeEvent(input$show, {
    plotVisible(TRUE)
  })
  
  observeEvent(input$hide, {
    plotVisible(FALSE)
  })
  
  output$plotVisible <- reactive({
    plotVisible()
  })
  
  outputOptions(output, "plotVisible", suspendWhenHidden = FALSE)
  
  # Display heat map
  output$heatmap <- renderPlot({
    req(plotVisible())
    req(final_table())
    
    ft <- final_table()
    pheatmap(ft,
             clustering_method = "none",  # Turn off clustering
             main = "",
             fontsize = 10,  # Adjust font size
             cellwidth = 30,  # Adjust cell width
             cellheight = 30,  # Adjust cell height
             cluster_cols = FALSE,  # Turn off clustering for columns
             cluster_rows = FALSE,  # Turn off clustering for rows
             scale = "none",  # Do not scale the data
             border_color = NA,  # Remove border color
             show_rownames = TRUE,  # Show row names
             show_colnames = TRUE,  # Show column names
             annotation_names_row = TRUE,  # Show row annotation names
             annotation_names_col = TRUE,  # Show column annotation names
             annotation_legend = TRUE  # Show annotation legend
    )
  })
  
  # Reactive values: needed for 3D visualization of PDB files, identification of chains within PDB files, and for 
  # allowing the user to hide/show PDB structure after one has been uploaded.
  pdb_data = reactiveVal(NULL)
  pdb_object = reactiveVal(NULL)
  pdb_window = reactiveVal(NULL)
  chains = reactiveVal(NULL)
  hide_pdb = reactiveVal(FALSE)
  showing_pdb = reactiveVal(TRUE)
  pres_res = reactiveVal(NULL)
  
  # Automatically displays structure after upload
  observeEvent(input$pdb, {
    req(input$pdb)
    pdb_file <- input$pdb$datapath
    pdb_data(pdb_file)
    
    # Distinguishes between the two proteins in the multimer, eg. chain A and chain B.
    nr_pdb_object <- read.pdb(pdb_file)
    pdb_object(nr_pdb_object)
    chains(unique(pdb_object()$atom$chain))
    
    # PDB model rendering was done using functions from the r3dmol library (Su & Johnston).
    pdb_window(
      r3dmol(  
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = pdb_data(), 
          format = "pdb"
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains()[1]),
          style = m_style_cartoon(
            color = "hotpink"
          )
        ) %>%
        m_set_style(
          sel = m_sel(chain = chains()[2]),
          style = m_style_cartoon(
            color = "#00cc96"
          )
        )
    )
    
    output$structure3d <- renderR3dmol({
      pdb_window() %>%
        m_zoom_to()
    })
  })
  
  # Allows user to interact with 3D model using the table of potential interactions
  observeEvent(input$dataTable_rows_selected, {
    req(showing_pdb())
    req(input$pdb)
    selected_row <- input$dataTable_rows_selected
    if(length(selected_row) > 0){
      selected_data <- displayed_df() [selected_row, ]
      
      range1 = selected_data[["Range 1"]]
      range2 = selected_data[["Range 2"]]
      
      if(length(unlist(strsplit(range1, ", "))) > 1){
        range1 = multi_range_conversion(range1)
      } else {
        range1 = range_conversion(range1)
      }
      
      if(length(unlist(strsplit(range2, ", "))) > 1){
        range2 = multi_range_conversion(range2)
      } else {
        range2 = range_conversion(range2)
      }
      
      output$structure3d <- renderR3dmol({
        pdb_window() %>%
          m_set_style(
            sel = m_sel(chain = chains()[1], resi = range1),
            style = m_style_cartoon(
              color = "blue"
            )
          ) %>%
          m_set_style(
            sel = m_sel(chain = chains()[2], resi = range2),
            style = m_style_cartoon(
              color = "darkorange"
            )
          )
      })
    }
  })
  
  # Show PDB button
  observeEvent(input$showpdb, {
    showing_pdb(TRUE)
    req(input$pdb)
    
    output$structure3d <- renderR3dmol({
      pdb_window()
    })
  })
  
  # Hide PDB button
  observeEvent(input$hidepdb, {
    hide_pdb(TRUE)
    showing_pdb(FALSE)
    req(hide_pdb())
    
    output$structure3d <- renderR3dmol({
      r3dmol(
        viewer_spec = m_viewer_spec(
          cartoonQuality = 10,
          lowerZoomLimit = 50,
          upperZoomLimit = 350
        )
      ) %>%
        m_add_model(
          data = NULL,
          format = "pdb"
        )
    })
  })
  
  # Allows user to refresh PDB file to original state
  observeEvent(input$refreshPdb, {
    req(input$pdb)
    req(showing_pdb())
    
    output$structure3d <- renderR3dmol({
      pdb_window()
    })
  })
  
  filtered = reactiveVal(FALSE)
  
  # Allows user to filter data frame based on distances found within PDB file
  observeEvent(input$cdFilter, {
    req(results())
    req(pdb_data())
    req(input$pdbFilter)
    
    filtered(TRUE)
    
    if (!is.null(input$pdbFilter) && !is.na(input$pdbFilter) && input$pdbFilter != ""){
      filteredpdb_data <- results()
      if(!is.null(filteredpdb_data)) {
        filteredpdb_data <- filter_by_distance(results(), pdb_object(), input$pdbFilter, chains())
        if(nrow(filteredpdb_data) > 0){
          clean_filtered_pdb_data <- clean_filtered_rows(filteredpdb_data)
          displayed_df(clean_filtered_pdb_data)
          output$dataTable <- renderDT(datatable(clean_filtered_pdb_data, selection = 'single'))
        } else {
          displayed_df(filteredpdb_data)
          output$dataTable <- renderDT(datatable(filteredpdb_data))
        }
      }
    }
  })
  
  # Allows user to reveal all contacts detecting within PDB file, not just those predicted interactions that fall
  # within the desired contact distance.
  observeEvent(input$unearth, {
    req(protein1())
    req(protein2())
    req(pdb_object())
    
    filtered(TRUE)
    
    if(db_id(protein1()) == 1){
      protein1_packed = interpro_col_names_clean_ranges(protein1())
    } else {
      protein1_packed = elm_col_names_clean_ranges(protein1())
    }
    
    if(db_id(protein2()) == 1){
      protein2_packed = interpro_col_names_clean_ranges(protein2())
    } else {
      protein2_packed = elm_col_names_clean_ranges(protein2())
    }
    
    protein1 = range_dumper(protein1_packed)
    protein2 = range_dumper(protein2_packed)
    
    contacts = extract_contacts(pdb_object(), input$pdbFilter, chains())
    
    all_pdb_contacts = contact_unearther(protein1, protein2, protein1_packed, protein2_packed, contacts)
    cleaned_pdb_contacts = clean_filtered_rows(all_pdb_contacts)
    
    consolidated_contacts = consolidate_contacts(cleaned_pdb_contacts)
    
    if(nrow(consolidated_contacts > 0)){
      displayed_df(consolidated_contacts)
      output$dataTable <- renderDT(datatable(consolidated_contacts, selection = 'single'))
    } else {
      empty_df = data.frame(matrix(ncol = 6))
      colnames(empty_df) = c('Protein 1', 'Protein 2', 'Range 1', 'Range 2', 'Residue 1', 'Residue 2')
      output$dataTable <- renderDT(datatable(empty_df, selection = 'single'))
    }
  })
  
  # Allows user to revert the filtered data frame back to the original
  observeEvent(input$cdRevert, {
    filtered(FALSE)
    
    displayed_df(results())
    output$dataTable <- renderDT(datatable(results(), selection = 'single'))
  })
  
  # Allows the user to add labels to residues coming in 'contact,' as determined by the contact distance they 
  # decided to filter for. Also changes contacting residues to ball and stick form, to improve the user's ability
  # to pinpoint the location of residues of interest.
  observeEvent(input$cdLabel, {
    pres_res(TRUE)
    req(filtered)
    
    observeEvent(input$dataTable_rows_selected, {
      req(showing_pdb())
      req(pres_res())
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "blue"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "darkorange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_res_labels(sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", "))))) %>%
            m_add_res_labels(sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))))
        })
      }
    })
  })
  
  # Allows the user to get rid of residue labels, but keeps highlighted residues in ball and stick form.
  observeEvent(input$cdRemLabel, {
    pres_res(FALSE)
    req(filtered)
    
    observeEvent(input$dataTable_rows_selected, {
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        res1 = selected_data[["Residue 1"]]
        res2 = selected_data[["Residue 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "blue"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "darkorange"
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[1], resi = as.numeric(unlist(strsplit(res1, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            ) %>%
            m_add_style(
              sel = m_sel(chain = chains()[2], resi = as.numeric(unlist(strsplit(res2, ", ")))),
              style = c(
                m_style_stick(),
                m_style_sphere(scale = 0.3)
              )
            )
        })
      }
    })
  })
  
  # Allows the user to set PDB view to only cartoon, no ball and stick
  observeEvent(input$cartoonPlease, {
    req(filtered)
    
    observeEvent(input$dataTable_rows_selected, {
      selected_row <- input$dataTable_rows_selected
      if(length(selected_row) > 0){
        selected_data <- displayed_df() [selected_row, ]
        
        range1 = selected_data[["Range 1"]]
        range2 = selected_data[["Range 2"]]
        
        if(length(unlist(strsplit(range1, ", "))) > 1){
          range1 = multi_range_conversion(range1)
        } else {
          range1 = range_conversion(range1)
        }
        
        if(length(unlist(strsplit(range2, ", "))) > 1){
          range2 = multi_range_conversion(range2)
        } else {
          range2 = range_conversion(range2)
        }
        
        output$structure3d <- renderR3dmol({
          pdb_window() %>%
            m_set_style(
              sel = m_sel(chain = chains()[1], resi = range1),
              style = m_style_cartoon(
                color = "blue"
              )
            ) %>%
            m_set_style(
              sel = m_sel(chain = chains()[2], resi = range2),
              style = m_style_cartoon(
                color = "darkorange"
              )
            )
        })
      }
    })
  })
  
}

# Launch app
shinyApp(ui = ui, server = server)
